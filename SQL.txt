Установка

Скачать Docker - это приложение которое запускает "контейнеры"

docker pull mysql - ввести в командной строке Terminal

docker run --rm --name skill-sql -e MYSQL_ROOT_PASSWORD=test -e MYSQL_DATABASE=skillbox -d mysql     - ввести в Терминал, стартует сервер

docker exec -it skill-sql mysql -ptest    - ввести в Терминале, подключиться к MySQL серверу

exit - выйти (отключиться) из MySQL чтобы загрузить "дамп"

docker exec -i skill-sql mysql -ptest --default-character-set=utf8 skillbox < /users/egor/downloads/skillbox_sql_dump.sql  - в Терминале, загрузить дамп , где "./some/folder/dump.sql" - это путь к файлу у меня было "/users//egor/downloads/skillbox.sql"

docker exec -it skill-sql mysql -ptest     - подключиться заново

SHOW TABLES IN skillbox;        - ввести название таблицы и проверить все ли загрузилось



charset utf8;    - в терминале, если ????? вместо русских букв






















Запуск

docker run --rm --name skill-sql -e MYSQL_ROOT_PASSWORD=test -e MYSQL_DATABASE=skillbox -d mysql - запускает сервер, его можно посмотреть в самом Докере

docker exec -i skill-sql mysql -ptest --default-character-set=utf8 skillbox < /users/egor/downloads/skillbox_sql_dump.sql - загружаем дамп

docker exec -it skill-sql mysql -ptest - подключаемся к mysql серверу

show tables; - показать таблицы






















Список команд:

USE skillbox; - выбрать раздел базы данных skillbox

SHOW TABLES; - показать таблицы внутри

DESCRIBE Students; - показать поле Students внутри skillbox как таблицу

INSERT INTO ... (name, age) VALUES ("Egor", 25) - вставить

SELECT ... FROM ...
   1) DISTINCT - SELECT DISTINCT name FROM Students;

WHERE

ORDER BY
   1) DESC
   2) ACS

LIMIT

SELECT ... AS ...

JOIN ... ON ...

() UNION ()
   1)UNION ALL

SELECT AVG() - среднее

MAX - максимальное

MIN - минимальное

SUM - сумма всех значений

COUNT - посчитать кол-во строк или чего либо

GROUP BY - для множественной агрегации, например AVG() выведет не 1 строку, а 6 строк разного типа и средние значения для них

DATEDIFF() - DATEDIFF(NOW(), date2) вывести разницу в датах в днях, NOW() выводит сейчас

IF(age > 50, "OLD", "YOUNG") - создать колонку по названию условия, и в колонке писать "OLD" если условие выполняется и "YOUNG" если нет

CONCAT("My name is ", name) - создать колонку с текстом который внутри, принимает переменные






































Все команды заканчиваются на ; или \G

Дамп - это сами таблицы, их нужно загрузить на сервер перед тем как работать с ними




USE skillbox; - выбрать раздел базы данных skillbox

SHOW TABLES; - показать таблицы внутри

DESCRIBE Students; - показать поле Students внутри skillbox как таблицу

describe Students\G - посмотреть структуру таблицы Students внутри таблицы, \G чтобы вывести инфу построчно
























Добавление и удаление из таблицы, модификация данных



Вставка/Удаление:

INSERT INTO Students (name, age, id) VALUES ("Egor", 25, 101) - вставить

UPDATE Students SET name = "Misha" WHERE id = 101; - изменить значение

UPDATE Courses SET price = price*0.9 WHERE type = "PROGRAMMING"; - сделать скидку 10% на все курсы по программированиюннпагнпа



Таблицы:

CREATE TABLE PurchaseList(
student_name VARCHAR(500),   - VARCHAR = String, 500 это ограничение кол-ва знаков
course_name VARCHAR(500), 
price INT,                   - инт есть инт
subscription_date DATETIME); - DATETIME тип переменной даты, очень удобно




INSERT SELECT

Это когда мы вставляем в таблицу через SELECT, очень удобно и быстро

INSERT INTO PurchaseList(student_name, course_name, price, subscription_date) SELECT Students.name AS student_name, Courses.name AS course_name, Courses.price AS price, Subscriptions.subscription_date AS subscription_date FROM Courses JOIN Subscriptions ON Subscriptions.course_id = Courses.id JOIN Students ON Subscriptions.student_id = Students.id;

 


















Выборка данных

Каждое выражение должно содержать SELECT FROM, остальные опциональны

Важно использовать именно такую структуру:       SELECT FROM -> WHERE -> ORDER BY -> LIMIT


SELECT name, type FROM Courses; - я выбираю имя и тип из таблицы Courses

SELECT * FROM STUDENTS; - выбрать ВСЮ инфу обо ВСЕХ студентах












Фильтрация

WHERE - клучевая фраза в фильтрации запроса





SELECT * FROM Courses WHERE type="PROGRAMMING"; - выбрать все поля в курсах, у которых тип "Programming"

SELECT name FROM Students WHERE age > 35; - выбрать всех студентов(имена), у которых возраст больше 35 лет

SELECT * FROM Teachers WHERE salary > 20000; - выбрать все поля у учителей, зп которых выше 20 тыс


Несколько условий выборки

SELECT * FROM Teachers WHERE salary > 20000 AND age < 30; - выбрать все поля у учителей, зп которых выше 20 тыс, и возраст меньше 30 лет




















Сортировка выборки

ORDER BY - отсортировать по какому то полю

DESC - descending, отсортировать по убыванию

ASC - ascending, отсортировать по возрастанию



SELECT * Students ORDER BY age; - выбрать всех студентов отсортированных по возрасту

SELECT * Students ORDER BY age DESC; - выбрать всех студентов отсортированных по убыванию возраста


Множественная сортировка

SELECT * FROM Teachers ORDER BY age DESC, salary ASC; - отсортировать всех учителей сначала по возрасту(по убыванию), а те у кого один возраст - по зарплате(по возрастанию)

















LIMIT - Ограничение числа выборки записей

LIMIT - ключевое слово




SELECT * FROM Teachers ORDER BY age LIMIT 3; - показать топ 3 молодых учителей по возрасту



БЛИЦ

SELECT names, duration, students_count FROM Courses WHERE type="PROGRAMMING" ORDER BY price LIMIT 3; - из таблицы Courses выбрать только 3 самых дешевых курса типа "Programming", и показать название курса, длительности и кол-во студентов на этом курсе


















Выбор только УНИКАЛЬНЫХ значений

DISTINCT - выбрать только уникальные значения, ставится после SELECT, перед именем поля



SELECT type FROM Courses; - выдаст большой список одинаковых типов, потому что там много курсов и для каждого проставлен тип

SELECT DISTINCT type FROM Courses; - выдаст только уникальные типы, там будет всего 4 (Программирование, Дизайн, Маркетинг, Менеджмент)

SELECT DISTINCT type, duration FROM Courses; - выбрать уникальные сочетания типа И длительности 





















Обьединение таблиц в одну выборку

UNION - ключевое слово "обьединить"

Чтобы он работал, в обоих запросах должно быть ОБЯЗАТЕЛЬНО одинаковое кол-во выбираемых колонок

По умолчанию выкидывает дубликаты(DISTINCT)

UNION ALL - чтобы отключить выборку только уникальных элементов (NOT DISTINCT)

(сложная выборка) UNION (сложная выборка) - выборки заносим в скобки () 






SELECT name FROM Students UNION SELECT name FROM Teachers; - список из имен ВСЕХ студентов И ВСЕХ преподавателей без дубликатов(если они есть)

SELECT age, name FROM Teachers UNION ALL SELECT age, name FROM Students; - выбрать имена и возраст всех студентов и учителей, без выкидывания дубликатов(если вдруг один человек и студенто и учитель)

(SELECT name FROM Students ORDER BY age LIMIT 3) UNION ALL (SELECT name FROM Teachers ORDER BY age DESC LIMIT 3) - Если обьединяем сложные выборки заносим их в скобки























Соединение таблиц по связанным полям

Отличие от UNION - UNION просто визуально обьединяет колонки в один лист, а JOIN соединяет именно по информации. Можно думать так 
"Если мне в SELECT нужно вывести значения из нескольких таблиц и они связаны, то использую JOIN"


JOIN - ключевое слово




SELECT price, Courses.name, Teachers.name         - здесь есть поля одновременно из таблицы Courses и Teachers
FROM Teachers                                     - выбираем таблицу Teachers
JOIN Courses ON Courses.teacher_id = Teachers.id  - подсоединяем Courses по соотношению teacher_id
ORDER BY price;                                   - вывести цену курса, имя курса и имя учителя который ведет(Courses и Teachers связаны полем teacher_id)

                                             



SELECT Courses.name, Students.name, Subscriptions.subscription_date   - выбираем поля
FROM Courses                                                          - выбираем основную таблицу
JOIN Subscriptions ON Courses.id = Subscriptions.course_id            - подсоединяем Подписки по соотношению id курса
JOIN Students ON Students.id = Subscriptions.student_id               - и студентов по id студента
WHERE type="DESIGN"                                                   - выбираем только курсы по дизайну
ORDER BY subscription_date                                            - сортируем по дате подписки
LIMIT 3;                                                              - вывести топ 3 Имя курса, Имя студента и дату подписки, отсортированные по дате подписки

























Подзапросы

По сути это похоже на JOIN, только JOIN выбирает из двух таблиц связанных хотябы одним общим полем, а подзапросы используют когда между таблицами нет связи

Подзапрос работает по принципу цикла for(), для каждого поля из таблицы Students будет проверяться подзапрос ()


SELECT age,name,                                                                   - показать возраст и имя студента
(SELECT COUNT(*) FROM Teachers WHERE Teachers.age > Students.age) as older_count   - для каждого элемента(студента) из Students будет проверяться это условие
FROM Students                                                                      - выбираем age и name именно из Students
ORDER BY older_count;                                                              - узнать сколько преподователей старше каждого студента в списке




























Изменение названия колонки

SELECT salary * 12 AS annual_salary FROM Teachers; - вывести зарплаты умноженные на 12(годовая) и названю ее annual_salary


























Математические выражения AVG, MAX и тд

Это всё агрегирующие функции - в конце возвращают всегда одну строку

Их можно группировать и проводить агрегацию по отдельным группам через GROUP BY (об этом ниже в Агрегации)

AVG - среднее

MAX - максимальное

MIN - минимальное

SUM - сумма всех значений

COUNT - посчитать кол-во строк или чего либо







SELECT AVG(age) as average_age FROM Teachers WHERE salary > 10000; -  показать ср возраст среди учителей у кого зп больше 10 тыс и назвать колонку average_age

SELECT SUM(price) as price_of_all_courses FROM Courses; - сумму этих полей, здесь сумма цен всех курсов

SELECT SUM(duration * 60) as duration_of_all_courses FROM Courses; -  длительность всех курсов в минутах






















Разница дат, подсчет дней, даты, работа с датами

DATEDIFF(date1, date2) - ключевое слово, считает разницу в датах по дням 

SELECT DATEDIFF(NOW(), registration_date), name FROM Students; - вывести как много дней прошло с даты регистрации студента

























IF условный оператор

IF(age > 40, "OLD", "YOUNG") - создает колонку, если условие выполняет пишет туда первое значение, если нет то второе

SELECT name, IF(students_count > 500, "FULL", "NOT FULL") FROM Courses; - 2 колонки: имя, вторая создает колонку по названию условия и выводит FULL если условие выполняется и NOT FULL если не выполняется



















Concat вывод текста, работа с текстом

CONCAT() - создать колонку, где по JAVA принципам будут склеены строки с переменными

SELECT CONCAT("Buy new course ", name, " it's only ", price, " rub") AS Advertisment FROM Courses; - создать колонку, назвать ее Advertisment и вывести в неё текст который внутри
































Агрегация данных, агрегирующие функции

Агрегация - обьединение нескольких элементов в один

Агрегирующая функция - ф-я которая применяется не к каждой строчке в выборке, а ко всей выборке целиком

В результате нам возвращается одна строка, вне зависимости сколько строк мы выбирали

Функции:

COUNT
AVG
MAX
MIN
SUM












Агрегация среди групп данных

GROUP BY - Группирует колонки по выбранному признаку и считает агрегацию в этих группах отдельнр Используется только при агрегации с AVG, MAX и тд 

Читать так: сначала SQL собирает группы, а только потом делает всю агрегацию в каждой отдельной группе

SELECT AVG(price) FROM ... GROUP BY ... ORDER BY






SELECT type, AVG(price) FROM Courses GROUP BY type; - сгруппировать все курсы по типу(Маркетинг и тд) и вывести тип курса и среднюю цену за этот тип курса 


SELECT Teachers.name, COUNT(*)                     - колонки имя учителя, кол-во курсов (изначально считает кол-во курсов вообще)
FROM Courses                                       - из Курсов
JOIN Teachers ON Teachers.id = Courses.teacher_id  - здесь фильтруем COUNT(*) соотнося учителей только с курсами которые они ведут
GROUP BY Teachers.id                               - группируем курсы по учителю, если один учитель веден неск курсов, они будут посчитаны через COUNT(*)
ORDER BY COUNT(*) DESC LIMIT 5;                    - вывести то, сколько курсов ведут преподаватели



















































ДЗ


К уроку 3
1) SELECT * FROM Students ORDER BY registration_date;
2) SELECT * FROM Courses WHERE students_count > 4 AND duration > 10\G
3) (SELECT name FROM Students ORDER BY age LIMIT 3) 
UNION ALL 
(SELECT name FROM Teachers ORDER BY age DESC LIMIT 3) 
UNION ALL (SELECT name FROM Courses ORDER BY duration DESC LIMIT 3);


К уроку 4
1) SELECT AVG(age) as average_age FROM Teachers WHERE salary > 10000;
2) SELECT SUM(price) as price_of_all_courses FROM Courses;
3) SELECT SUM(duration * 60) as duration_of_all_courses FROM Courses;




















