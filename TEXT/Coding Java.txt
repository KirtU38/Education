Вопросы к собеседованию:
1) equals() ,hashcode() и HashMap, всё о хэше и HashMap, HashSet, коллизии, LinkedHashSet и LinkedHashMap, и TreeSet
2) ArrayList vs LinkedList
3) Interface vs Absctract class, как в джаве решается Diamond problem, default  методы в Интерфейсахё
4) Inner classes vs Static inner classes, Anonymous, анонимные классы
5) Serializable
6) Iterable, Iterator
7) StringBuilder и StringBuffer, почему не добавлять просто в String всё
8) Дженерики, Generics
9) Collections, все коллекции, что относится к коллекциям и тд
	a) List vs Set (Лист упорядочен, может содержать дубликаты и у него есть доступ по индеку, а у Сета нет) 
10) Comparator, 1, -1 и 0 тд, какие коллекции могут использовать его
11) O(n), Collections time and space complexity, constant time = O(1) моментально, 1 опперация, linear = O(n) значит с кол0вом элементов растет кол-во операций и log(n)
12) Stream API - глубоко затестить все методы и запомнить
	a) Терминальные операции, terminal operations(collect, forEach)
	b) Вообще какие есть типы операций
	с) Что означает что Стримы "lazy"
	d) Spliterator - хотябы базовые знания
13) Лямбды вообще впринципе
14) Функциональные интерфейсы(Runnable) - интерфейсы с 1 методом, их круто использовать с Лямбдами
15) Маркерные интерфейсы типа Serializable
16) Многопоточность, concurrency
	a) Thread vs Runnable
	b) synchronized методы, static synchronized, synchronized блок
	с) Мониотор, mutex
	d) Atomic переменные
	e) double checked patter and why it doesn't work
	f) ExecutorService
	g) Future vs CompleteableFuture
17) Mutable Immutable, разобраться
18) КОдировки UTF-8 и тд, Стринг UTF-16
19) Java Time, Calendar и тд
20) Spring разобратсья под копотом
	a) @Bean
	b) @Transient
	c) @Component
	d) @Configuration
	e) Что такое IoT
	f) Dependency injection
21) Вообще все принципы ООП: Наследование, Абстракция, Полиформизм, Инкапсуляция. Что такое вообще ООП, почему оно лучше, зачем его применять(реюзабл код)
22) Принципы SOLID - очень важно
23) Функциональное программирование, functional programming (стримы, лямбды, имьютаблес и тд)
24) AOP - Аспектно ориентрированное программирование (Spring, Lombok)
25) JDBC драйвер
25) JPA и Hibernate, ORM, Spring Data JPA
26) PostgreSQL потренить
27) MongoDB
28) Redis
29) Log4j
30) HTTP изучить четко, OAuth2
31) REST - понять что именно это и расщифровывается (Representational State Transfer)
32) CI/CD - Continious Integration, Continious Delivery
33) Microservices, что такое микросервисы
	a) Kafka, JMS - для общения микросервисов (message queues)
34) Big Data, Spark
35) Тестирование: отличия юнит тестов, интеграционные тесты, JUnit
	a) TDD - Test Driven Development, почитать
	b) Test coverage
	c) Whitebox, blackbox
36) Алгоритмы и задачки (leetcode.com, codingbat.com)
37) Участи памяти в JVM: Stack, Heap
38) ENUM
39) 





















Полезные ссылки:
1) https://www.youtube.com/watch?v=oNFf_Bi1Wko    - Собеседование по Java с Алексом Шестеровым










public class Egor {
    public static void main(String[] args){

{

ТЕРМИНОЛОГИЯ Java

JDK - Java Development Kit(чтобы создавать код)
JSE - Java Standard Edition
JRE - Java Runtime Environment(чтобы запускать файлы Java на чем угодно)

Source code(.java) -> Java Compiler -> Byte code(.class) -> Java Virtual Machine(переводит код под нужное ПО) -> Native code(Windows, mac теперь могут его прочитать)

API - Application Programming Interface
ЭТО НАЧАЛО ЛЮБОЙ ПРОГРАММЫ

int name = "Egor" - тип ставится перед переменной
System.out.print() - выводит текст на той же строке
System.out.println() - выводит текст на новой строке(printNEWLINE)
String name = "Egor"; - двоеточие после каждой функции
SOUT - коротко

СРАВНЕНИЯ
ДЛЯ ЧИСЕЛ

== - равно 
!= - не равно
<= - меньше или равно
+= - плюс один

ДЛЯ ТЕКСТА
ПРИМЕР

while (!text.equals("quit")){    -   луп выполняется, пока переменная text не равно(!) слову ("quit")

ПОЛНАЯ ПРОГРАММА

Scanner scanner = new Scanner(System.in);                     - получаем инпут от пользователя, если он вводит "quit", программа заканчивается.
String input = "";                                            - задаем пустую переменную, чтобы не пришлось вводить scanner.nextLine().toLowerCase() два раза, вводим только в лупе
while (!input.equals("quit")){
       input = scanner.nextLine().toLowerCase();              - переводим все написанное в нижний регистр(.toLowerCase), чтобы quit работал всегда 
}


BREAK STATEMENT и CONTINUE
break;    - выходит из лупа
continue; - возвращает к началу лупа

ПРИМЕР

Scanner scanner = new Scanner(System.in);                     
String input = "";
while (!input.equals("quit")){
       input = scanner.nextLine().toLowerCase();
       if(input.equals("pass")){                            - дублируем всё, что написал пользователь, если введет pass, тогда мы не дублируем и возвращаемся в начало лупа 
          continue;
       if(input.equals("quit")){                            - дублируем всё, что написал пользователь, пока не введет quit, тогда мы не дублируем и выключаем программу
          break;
       }
       System.out.println(input);
}



WHILE LOOPS
while(){                          - так записывается
while (true){                     - бесконечный луп, пока не дойдет до Break
   break;


int x = 1;                        - функция выводит числа от 1 до 10
while (x<=10){
      System.out.println(x);
      x = x+1;


FOR LOOPS

for (int x=1; x<100; x+=1) - луп работает начиная с x=1, работает пока x меньше 100, и каждый луп добавляет к ику один(x+=1)


FOR EACH LOOPS

String[] fruits = {"Apple", "Mango", "Lemon"};
for (String oneFruit : fruits){                      - переменная oneFruit будет содержать каждое по очереди значение из переменной fruits
     System.out.println(oneFruit);
}

ПЕРЕМЕННЫЕ ВНУТРИ ЛУПОВ БУДУТ ОБНОВЛЯТЬСЯ КАЖДУЮ ИТЕРАЦИЮ ЛУПА
Если мы хотим накапливать какое-то значение, нужно создать переменную за границами лупа(перед ним)

МАССИВ ОТ 1 ДО 100 (ARRAYS, ИНДЕКСЫ)

int[] numbers = new int[101];                 - так с помощью forloop можно создать массив от 1 до 100 и вывести на экран
for (int x=0; x <= 100; x+=1){
     numbers[x] = x;
}
System.out.println(Arrays.toString(numbers));
 
ДРУГОЙ ПРИМЕР

String[] fruits = {"Apple", "Mango", "Lemon"};
for (int x = 0; x < fruits.length; x++){         - присваиваем x числовое значение, которое будет увеличиватсья на +1
  System.out.println(fruits[x]);              - выводим массив fruits, использую число x, которое сначала = 0, потом = 1, то есть использую[] скобки, мы воводим этим числом значения под этими индексами
}                                           














Переменные, ссылочные переменные(Reference variables, primitive types)



Примитивы, примитивные переменные:

byte    = 1 байт  = 8 разрядная (2 в 8 степени) = 256
short   = 2 байта = 16 разрядная = 65 тыс
int     = 4 байта = 32 разрядная = 4 млрд 
long    = 8 байт  = 64 разрядная
float   = 4 байта = 32 разрядная
double  = 8 байт  = 64 разрядная
char    = 2 байта = 16 разрядная = 'один символ'
boolean = 1 бит = true/false

Примитивы можно сравнивать через знак "==", т.к переменные примитивов хранят значения прямо внутри переменных

int number = 5;
int copy = number;
copy = 10;
Вывод:
number = 5
copy = 10

Примитивы не держат ссылку на один и тот же объект, даже если одна переменная копия другой, они просто независимо меняют свои значения



Ссылочные переменные:

Пример:

List<String> arr = new ArrayList<>(); - пример создания объекта, и присвоения его к переменной
List<String> copy = arr;              - мы не создаем другой объект, а на самом деле просто создаем ВТОРУЮ ССЫЛКУ на ТОТ ЖЕ САМЫЙ объект
copy.add("1 copy");                   - добавляем именно В КОПИЮ
System.out.println(arr);              - выводим оригинал и копию
System.out.println(copyArr);
Вывод:
[1 copy]                              - поменялись значения в обоих переменных, тк они ссылаются к одному объекту
[1 copy]


Переменная к НЕ ПРИМИТИВУ автоматически становится ссылочной






















Байти и биты(bytes and bits)

1 бит  = 1 или 0
1 байт = 8 бит = 2(8 степень) = 256 значений

byte   = 1 байт  = 8 разрядная (2 в 8 степени) = 256
short  = 2 байта = 16 разрядная = 65 тыс
int    = 4 байта = 32 разрядная = 4 млрд 
long   = 8 байт  = 64 разрядная
float  = 4 байта = 32 разрядная
double = 8 байт  = 64 разрядная

double и float не совсем точны при вычислениях, для≤ супер точных вычислений используется 














SWITCH

char cal = '*';
int one = 3;
int two = 7;

switch (cal){                            - так записывается switch
     case '*':                           - тут именно двоеточие(:)
          System.out.println(one*two);   
          break;                         - в конце каждого кейса нужно писать break, иначе тупо программа продолжит выполнять остальные кейсы
     case '/':
          System.out.println(one/two);
          break;                  


IF STATEMENTS

if(x == 10){ - так пишется иф
} else if {  - так пишется или если
} else {     - так пишется елсе


Тернарный оператор
System.out.println(canBuyAnything ? "Выберите напиток" : "Недостаточно средств") - если булин выполняется, то пишется "Выберите напиток", если нет "Недостаточно средств"

(boolean ? true : false)
 

СУПЕР СОКРАЩЕНИЕ IF
ОРИГИНАЛ
int income = 120_000;       - оригинал, если зарабатывает больше 100тыщ, то даем класу звание первого, если меньше, то эконом
String className;
if (income > 100_000){
       className = "First";
} else{
       className = "Economy";
}

СОКРАЩЕНИЕ
int income = 120_000;
String className = income > 100_000 ? "First" : "Economy"; - доход больше 100_000(?), если да, то первый класс, если нет(:), то экономный


BOOLEAN БУЛИАН TRUE FALSE

boolean hasHighIncome = true;                                      - преверяем хороший ли заработок
boolean hasGoodCredit = true;                                      - кредитная история
boolean hasCriminal = true;                                        - криминальные записи
boolean isGreat = (hasGoodCredit || hasGoodCredit) && !hasCriminal; - если хороший заработок ИЛИ хорошая история, И НЕТ записей в криминале, то isGreat(красавчик)
System.out.println(isGreat);

СУПЕР СОКРАЩЕНИЕ В БУЛИНЕ

income = 120_000
boolean hasHighIncome = income > 100_000 - булин TRUE только если выполняется условие внутри(>100_000), если нет, то он FALSE



&& - и (x >=1 && x <=100)
|| - или

INPUTS
import java.util.Scanner; - в самом начале, загружает функцию инпута
Scanner one = new Scanner(System.in); - задать переменной one инпут от юзера
double one = input.nextDouble(); - для переменной one задать инпут(double это тип, вроде float)
input.nextDouble(); - для любых чисел
input.nextLine();   - для текста
input.next().charAt(0); - для знаков типа *, next говорит запомнить что ты написал, charAt(0) возвращает первую букву из слова(типа индекс).



КАЛЬКУЛЯТОР

 Scanner input = new Scanner(System.in);  - калькулятор с инпутами
        
        double one = input.nextDouble();
        char cal = input.next().charAt(0);
        double two = input.nextDouble();
        if (cal == '*'){
            System.out.println(one*two);
        }
        if (cal == '/'){
            System.out.println(one/two);
        }
        if (cal == '+'){
            System.out.println(one+two);
        } else {
            System.out.println(one-two);
        }


БЕСКОНЕЧНЫЙ КАЛЬКУЛЯТОР

Scanner input = new Scanner(System.in);
        boolean run = true;
        while (run) {
            double one = input.nextDouble();
            char cal = input.next().charAt(0);
            double two = input.nextDouble();
            if (cal == '*') {
                System.out.println(one * two);
            }
            if (cal == '/') {
                System.out.println(one / two);
            }
            if (cal == '+') {
                System.out.println(one + two);
            }
            if (cal == '-'){
                System.out.println(one - two);
            }
        }


МАССИВЫ

СКОПИРОВАТЬ МАССИВ

System.arraycopy(files, startOffset, subArray, 0, subArray.length);  - 1) источник 2) с какого индекса источника 3) куда 4) с какого индекса 5) длина конечного массива
                   1           2          3    4         5


String[] words = {"one","two","three","four"}; - присвоить п-ой word массив с помощью [], сами переменные сторятся с помощью {}
или
int[] numbers = new int[5]; - можно так, но это муторно
numbers[1] = 1; - присвоить первому индексы значение 1 
System.out.println(Arrays.toString(numbers)); - это чтобы он вывел именно числа, иначе выдаст место в памяти из каши

int[] numbers = {1,65,13,75,13,2,1467};
System.out.println(Arrays.toString(numbers)); - всегда вводим Arrays и toString чтобы перевести числа из массива в реальные числа
Arrays.sort(numbers) - отсортировать номера в переменной numbers 


РАНДОМНЫЙ ВЫБОР ИЗ МАССИВОВ

String[] words = {"one","two","three","four"};             - массивы со словами
String[] words1 = {"black","white","asian","gay"};
String[] words2 = {"woman","man","girl","boy"};
int len = words.length;                                    - вычисляем длину массивов, присваиваем переенным len, len1 и тд
int len1 = words.length;
int len2 = words.length;
int random = (int) (Math.random() * len);                  - выбираем рандомный индекс в массиве, (int) нужно чтобы рандомайзер был целым числом
int random1 = (int) (Math.random() * len1);
int random2 = (int) (Math.random() * len2);
System.out.println(words[random]+" "+words1[random1]+" "+words2[random2]);  -  выводим массивы, [random] в квадратных скобках, потому что выводим индекс, то                                                                                есть одно слово, которое выбирается рандомно с помощью пред функции


ОБЬЕКТЫ
Метод - то, что обьект делает
Переменная экземпляра - то, что обьект ЗНАЕТ о себе
Экземпляр - синоним обьекта
Класс - это шаблон для обьекта


ТИПЫ ЧИСЕЛ
byte(-128/127) - short(-32k/32k) - int(-2B/2B) - long(в конце 123L) - float(любые числа 123f) - double(тоже)

ТИПЫ ТЕКСТА
char letter = 'A' - одинарные ковычки

РАЗНИЦА ПРИМИТИВНЫХ И РЕФЕРЕНСНЫХ ТИПОВ

Примитивные абсолютно не зависят от друг друг и выражение не будет работать:
int x = 1;
int y = x;
x = x + 12;
System.out.println(y);     -   он выдаст y = 1

Референсные будут работать(пример Point), потому что они записывают в себя их аддрес в памяти

Point point1 = new Point(1,1);
Point point2 = point1;
point1.x = 12;
System.out.println(point2);

x=12, y=1

Все референсные переменные(кроме String) начинаются с new
Date one = new Date();
Scaner one = new Scaner(); 

Функции(или методы) могут быть только у референсных типов
.indexOf()
.replace()
.toUpperCase()

ESCAPE SEQUENCE(специальные символы)

\" - если мы реально хотим напечатать ковычки
\\ - если мы реально хотим напечатать бэкслэш
\n - сделать отступ, на новой строке
\t - добавить таб
\u - напечатать симвов, например \u20AC - символ евро


ПОДРУЖИТЬ STRING с ЧИСЛАМИ

float x = 3.14;
int y = (int)x + 1;              -  только добавляя (int) перед иксом у нас получится ответ 4, потому int только целые


String x = "1";
int y = Integer.parseInt(x) + 1;   - меняем в перменной x текст "1", на число 1 функцией Integer.parseInt(x)

Integer.parseInt()    - из текста в целые
Double.parseDouble()  - из текста в любые
Float.parseFloat()    - из текста в любые

КАЗИНО

int[] stream = IntStream.range(1, 102).toArray();    - создаем набор целых чисел от 1 до 100 для переменной stream
int aLen = stream.length;                            - задаем переменной aLen длину нашего массива(100)
int randomNumber = 1;                                - задаем начальное значение, иначе while не запустится
int x = 0;                                           - задаем перменной x значение, она будет номером строки

while (randomNumber != 100){
      randomNumber = (int) (Math.random() * aLen);   - внутри while рандомизируем переменную длины aLen
      x+=1;                                          - каждый луп добавляем к номеру строки 1
      System.out.println(x+". "+asd);


MATH
Math.random() - генерирует числа от 0 до 1(0.156335789)
Math.random() * 100 - генерировать числа от 0 до 100


int result = (int) (Math.random() * 100);       - int чтобы вывел целое число, (int) кастим всё что там будет в целое   
System.out.println(result);                       число, (Math.random() * 100) в скобках, чтобы получить число от 0 до 100, иначе получается 0                               
double result = Math.round(Math.random() * 100); - можно и так, но .round выводит long число, поэтому в начале будет
System.out.println(result);                        double, сам рандом в скобках у round


















КОНВЕРТИРОВАНИЕ(NumberFormat)

NumberFormat currency = NumberFormat.getCurrencyInstance(); - создаем обьект через метод .getCurrency
String result = currency.format(123456.789);                - используем метод .format, чтобы перевести это число в форму 123 456,79 руб.
System.out.println(result);

ИЛИ

String result = NumberFormat.getCurrencyInstance().format(123456.789); - то же самое, только с двойным методом и короче
System.out.println(result);



NumberFormat numberFormat = NumberFormat.getCurrencyInstance(Locale.US);
double a = 67.9;
System.out.println(numberFormat.format(a));
Вывод:
$67.90



















КАЛЬКУЛЯТОР КРЕДИТА

Scanner input = new Scanner(System.in);

System.out.print("Principal: ");
int principal = input.nextInt();
System.out.print("Annual Interest Rate: ");

float interest = input.nextFloat();

System.out.print("Period: ");
byte period = input.nextByte();

double result = principal*(interest/10+1)/period/12;
String resultFormatted = NumberFormat.getCurrencyInstance().format(result);
System.out.println("Mortgage: " + resultFormatted);

ВЫВОД:
Principal: 800000
Annual Interest Rate: 5,76
Period: 18
Mortgage: 5 837,04 руб.

КАЛЬКУЛЯТОР КРЕДИТА С  ВЫВОДОМ ОШИБОК

        Scanner input = new Scanner(System.in);
        int principal = 0;
        float interest = 0;
        byte period = 0;


        while (true){
            System.out.print("Principal: ");
            principal = input.nextInt();
            if (principal >= 1000 && principal <= 1_000_000){
                break;
            }
            System.out.println("Enter a value between 1k-1B");
        }

        while (true) {
            System.out.print("Annual Interest Rate: ");
            interest = input.nextFloat();
            if (interest >= 1 && interest <= 30) {
                break;
            }
            System.out.println("Between 1 and 30");
        }
        while (true) {
            System.out.print("Period: ");
            period = input.nextByte();
            if (period >= 1 && period <= 30) {
                break;
            }
            System.out.println("1 or 30 dude");
        }
        double result = principal*(interest/10+1)/period/12;
        String resultFormatted = NumberFormat.getCurrencyInstance().format(result);
        System.out.println("Mortgage: " + resultFormatted);

ИЛИ ТАК

System.out.print("Principal: ");
int principal = input.nextInt();
while (principal < 1000){
        System.out.println("NONONO");
        System.out.print("Principal: ");
        principal = input.nextInt();
 }


FIZZBUZZ GAME ДЕЛЕНИЕ С ОСТАТКОМ
С БУЛИНАМИ

Scanner input = new Scanner(System.in);                   - Игра, если число делится без остатка на 5 выводится Fizz, если на 3 то Fuzz, если и на 3 и на 5 то FizzBuzz, если нет, то выводим само число
System.out.print("Number: ");
int number = input.nextInt();

int fizz = number % 5;
boolean fizzIsTrue = fizz == 0;

int buzz = number % 3;
boolean buzzIfTrue = buzz == 0;
boolean nothingIsTrue = number % 5 != 0 && number % 3 != 0;
        
if (fizzIsTrue && buzzIfTrue) {                   - самые специфичные условия вверху, иначе всегда будет выдавать Fizz, самые простые условия внизу
       System.out.println("FizzBuzz");
} else if (fizzIsTrue) {
       System.out.println("Fizz");
} else if (buzzIfTrue) {
       System.out.println("Buzz");
} else if (nothingIsTrue){
       System.out.println(number);
}

ИЛИ БЕЗ БУЛИНОВ(короче)

Scanner input = new Scanner(System.in);           - тот же результат, только без булинов
System.out.print("Number: ");
int number = input.nextInt();

if (number % 5 == 0 && number % 3 == 0) {
     System.out.println("FizzBuzz");
} else if (number % 5 == 0) {
     System.out.println("Fizz");
} else if (number % 3 == 0) {
     System.out.println("Buzz");
} else if (number % 5 != 0 && number % 3 != 0){
     System.out.println(number);
}



Обьексто Ориентированное Программирование(ООП, Object oriented programming)
ПРИМЕР

public class Comparison {                                        - создаем класс Comparison

    Human x;                                                     - после класса всегда идут переменные(здесь обе переменные должны быть класса Human)
    Human y;

    public Comparison(Human x,Human y) {                         - после этого МОЖНО указать какие у класса будут переменные внутри, без которых он не может существовать
        this.x = x;                                              - здесь указываем, что эта переменная x равна x из набора переменных что повыше
        this.y = y;

    }

    public void comparenames() {                                 - а потом записываются методы, к примеру comparenames(), если цвет глаз человека(класса) x и y одинаковы, то написать об этом строку 
        if (x.eyeColor.equals(y.eyeColor)) {
            System.out.println("Your eyes are both " + x.eyeColor);

ДРУГОЙ ПРИМЕР

public class Human {                                     - вот класс ЧЕЛОВЕК
    Scanner scanner = new Scanner(System.in);            - добавляем сканер

    int age;                                             - добавляем переменные
    String name;
    String gender;
    String eyeColor;

    public void getInfo(){                               - добавляем метод УЗНАТЬ ИНФО, где ты вводишь инпут на имя, возраст и тд
        System.out.print("Name: ");
        name = scanner.nextLine();

САМА ПРОГРАММА

Human one = new Human();                                 - создаем обьекст Human и задаем ему переменную(имя можно сказать, но не здесь, тк имя вводит пользователь)
Human two = new Human();

one.getInfo();                                           - к переменной one класса Human применяем метод getInfo, который будет спрашивать у него инфо о нём
two.getInfo();

Comparison comparison = new Comparison(one, two);        - создаем обьект Comparison, задаём ему переменную comparison и указываем, что нужные классу Comparison переменные класса Human x и y - это
                                                           наши переменные one и two
comparison.comparenames();                               - у переменной comparison класса Comparison есть свои x и y, теперь применяем к к переменной метод .comparenames, который сравнит имена и
                                                           другие атрибуты(здесь неполная версия) и напишет соотвественные строки в выводе

















Big O, Data structures, Структуры данных, структура данных

Big O  - максимальное кол-во операций для выбранного алгоритма или структуры данных

O(1)   - займет ровно 1 операцию (самый быстрый)

0(log n) - считается самый лучший, дешевеет с ростом числа элементов, что окруто(очень быстрый и отлично scaleable)

O(n)   - означает что макс кол-во операций будет равно кол-ву элементов, чем больше элементов, тем дороже становится такой алгоритм, цена растет линейно (чуть медленней, но очень крутой, scaleable)

O(n^2) - n в квадрате значит что чем больше элементов, тем НАМНОГО больше становится операций (медленный, плохо scaleable)

0(2^n) - экспоненциальный самый плохой, цена растет по экспоненте(противоположен log n)







List - любые элементы, с индексами, медленнее (ArrayList, LinkedList)
Set  - только уникальные элементы, без индексов, супер быстрый (Hash, Tree)
Map  - <ключ, значение>, ключи уникальны (Hash, Tree)   



Hash - ищет прям по хэшу, но нет индекса и доступа:                                                    get(-),     contains(1),     add(1),     remove(1) ----- Hash

Array - у каждого элемента есть индекс и доступ по этому индексу:                                      get(1),     contains(n),     add(n),     remove(n) ----- Array

Stack - элементы добавляются поверх, есть индекс, последний добавленный удаляется первым(pop):         get(n),     contains(n),     add(1),     remove(1) ----- Stack

Queue - то же самое, только удаляется сначала первый элемент, самый старый(ass):                       get(n),     contains(n),     add(1),     remove(1) ----- Queue

List - пока не изучил :                                                                                get(n),     contains(n),     add(1),     remove(1) ----- List

Red-Black Tree - дерево, где самый короткий путь может быть короче самого длинного максимум в 2 раза: get(log n), contains(log n), add(log n), remove(log n) - Red-Black Tree




















Алгоритмы, дял алгоритмов





SWAP, swap elements, Легкий способ свапнуть поменять местами эелементы


Collections.swap(list, 0, 1); - свапает местами по индексы в List<>, поэтому Array[] нужно будет кастить через Arrays.asList()


ВАЖНО: array[] должен быть Классовым типом, а не примитивным


Integer[]   - СРАБОТАЕТ

int[] array - НЕ СРАБОТАЕТ



















SPlit array, split, mid

Вводим "split" там записан мой live template
























Рекурсия, как думать о рекурсии

1) Продумать base-case, тот вариант при котором метод возвращает предсказуемое значение (как 1е и 2е число Фиббоначи = 1)

2) Продумать рекурсию ->

Чтобы это сделать нудно думать только о 3х нодах:

1) Первый родительский - в него мы зайдем первым, но он будет последним для возврата значения

2) Его ребенок - он промежуточное звено

3) И ещё один ребенок, в него мы зайдем последним, но именно с него начнется возврат значений вверх по дереву

Продумав только эти 3 части, мы сможем понять всю работу дерева и нашей рекурсии



                 (Родитель)   - зайдет первым, вернет(значение) последним
                 /
            (Ребенок)         - промежуточный
             /
       (Возвратчик)           - зайдет последним, именно он начет возвращать значение вверх Ребенку и потом Родителю


В рекурсии обязательно должно быть прописанно АККУМУЛИРОВАНИЕ(накапливание значений) от Возвратчика вверх по дереву к Родителю:

1) "Test(n-1) + Test(n-2)" - Этого можно добиться через обычное сложение, если метод возвращает числа

2) list.addAll()           - Если метод возвращает List<>, то АККУМУЛИРУЕМ значения через .addAll






























ПЕРЕМЕШИВАНИЕ ЧИСЕЛ В СЛУЧАЙНОМ ПОРЯДКЕ БЕЗ ПОВТОРОВ(Shuffling, shuffle)

int[] array = IntStream.range(1, 11).toArray();                     - создаем массив

for (int i = 0; i < array.length; i++) {
         int randIndex = (int) (Math.random() * array.length);      - переменная randomIndex будет выдавать случ числа от меньшего до большего в нашем массиве(*array.length)
         int swappedNumber = array[i];                         - равно целому ЧИСЛУ(именно числу, это важно) 1[потому что под индексом 0], потом 2[1]
         array[i] = array[randIndex];                          - под индексом [0](число 1) теперь число под случ индексом, допустим [3](число 4)
         array[randIndex] = swappedNumber;                     - а под случайным индексом который выпал(в нашем случае [3], число 4), ставится число 1, а потом будет 2 и тд
}                                            - то есть мы заменяем число с 0 индекса на число с рандомного индекса, в это же время присваиваю этому случ индексу ЧИСЛО, которое заменили, получается                                                числа не повторяются
System.out.println(Arrays.toString(array));


Пузырьковая сортировка (Bubble sort)

Как выглядит класс с методами под сортировку

public class MyArrays {                                   - просто класс

    public int[] bubbleSort(int[] arr) {                - public int[]-нужно для работы с массивами, bubbleSort(int[] arr) - в методе нужно будет указать любой массим int[], arr заменится на наш массив

        for (int i = 0; i < arr.length - 1; i++) {      - сам наш метод сортировки
            for (int j = 0; j < arr.length - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int swapped = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = swapped;
                }
            }
        }
        return arr;                                     - т.к это метод, в них обязательно должен быть return перед концом метода
    }
}

MAIN будет выглядеть так

public class Main {
    public static void main(String[] args) {              - тут всё обычно
        MyArrays numbers = new MyArrays();                - создаем обьекст класса MyArrays
        int[] array = IntStream.range(1, 101).toArray();  - создаем сам массив

        numbers.shuffle(array);                           - вызываем метод .shuffle - перемешать
        System.out.println(Arrays.toString(array));

        numbers.bubbleSort(array);
        System.out.println(Arrays.toString(array));       - вызываем метод .bubbleSort - пузырьковая сортировка




ОДНО ПОВТОРЕНИЕ:
for (int j = 0; j < array.length - 1; j++) {  - если 8 чисел, то мы только 7 раз можем сравнить числа которые рядом, поэтому мы пускаем луп, пока array.length - 1 (7 сравнений)
     if (array[j] > array[j + 1]) {           - если число под индексом [0] больше, чем число под индексом [1](j+1), то
           int swapped = array[j];            - делаем свап, как в предыдущем примере перемешивания чисел
           array[j] = array[j + 1];
           array[j + 1] = swapped;
     }
}

ПОЛНЫЙ СОРТ

for(int i=0; i<array.length- 1; i++){          - а это задаем нам кол-во ВСЕХ проходов(в нашем случае 7 раз), то есть код ниже для одного прохода повторяется 7 раз
      for (int j=0; j<array.length - 1; j++){  - мы проходим все числа, меняем местами числа всё как надо один раз(это код одного прохода)
           if(array[j]>array[j+1]){
              int swapped = array[j];          - то есть мы прошли 7 раз(т.к 8 чисел), свапнули один раз всех числа
              array[j] = array[j+1]
              array[j+1] = swapped;
           }
      }
}

O(n^2) - т.к у нас array.length был 2 раза в нашем сорте, значит Big O(максимальное колво операций) у нас равно n в квадрате(n - колво действий)

Сортировка выбором, выборкой(Selection sort)

СУПЕР ПРОСТО(знаем что первое число 1, не универсален)

for(int i=0; i<array.length; i++){                    - это если мы знаем, что первое число в индексе 0, это 1
    for(int j=0; j<array.length; j++){
         array[j] = 1+j;
    }
}














































Конструктор, constructor

Если конструктора нет, то предоставляется дефолтный конструктор:


public class Test {

    int x;

    public Test(){} - дефолтный пустой конструктор








Если создан один конструктор, который отличается от этого дефолтного, то он становится дефолтным и его теперь ОБЯЗАНЫ ПЕРЕНАЗНАЧИТЬ Сабклассы:

public class Test {      - Суперкласс

    int x;

    public Test(int x){  - это теперь дефолтный
        this.x = x;
    }
}



public class TestChild extends Test {  - Сабкласс

    public TestChild(int x) {          - переназначенный конструктор
        super(x);
    }
}







super() должен быть вначале любого метода(если используется) кода и не может быть в одном методе с this()













Если мы хотим создать no-arg конструктор но у Суперкласса дефолтный только с arg, то поможет функция this():

public class Test {      -  Суперкласс

    int x;

    public Test(int x){  - дефолтный arg конструктор
        this.x = x;
    }
}



public class TestChild extends Test { - Сабкласс

    public TestChild(int x) {         - дефолтный(по наследованию) конструктор с arg
        super(x);
    }

    public TestChild() {              - новый no-arg конструктор, словом this() мы передаем значение для дефолтного(по наследованию) конструктора
        this(10);
    }
}


И теперь можно создать обьект TestChild без аргументов в конструкторе с дефолтным х=10:

TestChild testChild = new TestChild();
System.out.println(testChild.x);


Output: 10








 
Можно менять значения в super() у констурктора Сабкласса


public class TestChild extends Test {

    public TestChild(int x) {        
        super(x+1);
    }



TestChild testChild = new TestChild(10);    - теперь этот код выдаст 11
System.out.println(testChild.x);



Output: 11



































ТЕРМИНЫ

Класс - это мы создаем класс:
public class Human {

Методетод(функция) - действия:
public void speak(){
    System.out.println("I'm a human");

human.speak();
I'm a human

Обьект(экземпляр класса) - это обьект определенного класса, который мы создаем в мейне, чтобы с ним работать и вызывать на него методы:
Human egor = new Human();
egor.speak();

Переменные экземпляра(обьекта) или поля(fields) - переменные, заданные внутри класса:
public class Human {
    int age;
    int height;

Конструктор - значения, переменные или дейтвия, заданные классу как обязательные, внутри самого класса:
public class Human {
    int age;
    public Human(int age){            - это конструктор
        this.age = age;

или 

public Human(){                             - это тоже конструктор, если будет создан обьект этого класса, будет автоматически выводиться надпись I'm a human
        System.out.println("I'm a human");
    
Конструктор родителя всегда имеет приоритет над конструктором дочернего класса
Конструктор всегда называется ТОЧНО ТАКЖЕ, как называется сам КЛАСС

PUBLIC И PRIVATE

Public - значит переменные класса можно изменять где и как угодно, получать к ним доступ и менять в мейне, делать с ними что угодно

ПРИМЕР

public class Human {    -  класс Human
    int age = 12;       - переменная age = 12

В МЕЙНЕ
Human egor = new Human();

        System.out.println(egor.age);  - СРАБОТАЕТ, выдаст 12

ЕЩЁ ПРИМЕР

Human egor = new Human();
         
        egor.age = 25;                 - СРАБОТАЕТ, меняем переменную на 25

        System.out.println(egor.age);  - СРАБОТАЕТ, выдаст 25

Private - это значит что переменная будет иметь к себе доступ ТОЛЬКО внутри класса, к неё нет доступа в мейне, её нельзя изменить и тд, с ней можно будет писать МЕТОДЫ и тд только внутри класса

ПРИМЕР

public class Human {

    private int age = 12;           - делаем age приватным, к нему нет доступа в мейне, его нельзя изменить или распечатать

    public int getAge() {           - этой единственный способ заполучить число age(12) в мейне, опять же записав его в МЕТОД, ВНУТРИ КЛАССА Human
        return age;
ПРИМЕР

Human egor = new Human();

System.out.println(egor.getAge()); - СРАБОТАЕТ

System.out.println(egor.age);      - НЕ СРАБОТАЕТ

egor.age = 25                      - НЕ СРАБОТАЕТ


Static - это означает, что мы не должны создавать ОБЬЕКТ класса, чтобы выполнить этот метод(пишутся в мейне)

Static методы - не наследуются

ПРИМЕР
public class Main {
       public static void mergeSort(int[] arr, int lengthOfArray) {  - вот наш метод на сортировку прямо в мейне, теперь можем сделать так:

public static void main(String[] args) {                             - это уже в методе мейн
        int[] array = IntStream.range(1, 101).toArray();             - создаем массив array

        mergeSort(array,array.length);  -  и это сработает, а если без static, то нужно было бы создавать ОБЬЕКТ какого-то класса

БЕЗ STATIC

public class Main {
    public static void main(String[] args) {
        MyArrays numbers = new MyArrays();                 - создаем обьект numbers класса MyArrays(класс, в котором метод сортировки)
        int[] array = IntStream.range(1, 101).toArray();   - создаем переменную

        numbers.mergeSort(array,array.length);             - только к обьекту numbers сможем применить метод mergeSort со значением array

ДО
MyArrays numbers = new MyArrays();
numbers.mergeSort(array,array.length);
ПОСЛЕ
mergeSort(array,array.length);


VOID и другие модификаторы

Void - тип возвращаемого значения метода, который не должен возвращать НИКАКОЕ значение, а может только что-то ВЫПОЛНЯТЬ
ПРИМЕР





























Просто инфа, просто информация, разная информация

В linux все директории начинающиеся с точки - скрытые
.idea - значит папка скрытая























































Модификаторы доступа(private, public, protected)

public:
1) Везде

protected:
1) Внутри класса
2) Наследники
3) Внутри пакета (в папке)

private:
1) Внутри класса (всё private не наследуется)

Без модификатора доступа
package private:
1) Внутри класса
2) Внутри пакета (наследникам не передается)

















































КЛАССЫ
Наследование методов:
  
public class Animal {                        - старший класс(если пустой)
________________________________
public class Bird extends Animal {           - дочерний класс
      void fly(){                            - метод дочернего класса fly()
          System.out.println("FLYING");
________________________________
MAIN
public static void main(String[] args) {
        Animal eagle = new Bird();           - обьект старшего класса Animal, но сам обьект делаем Bird
        eagle.fly();                         - НЕ СРАБОТАЕТ, fly() просто не считывается

Сработает только если добавим в класс Animal:
void fly(){
    }                                        - при наследовании, если мы хотим чтобы дочерний класс Bird имел обозначение старшего Animal, то будут работать только методы, назначенные в старшем Animal
                                             - но мы можем их переназначить в дочернем Bird и всё будет работать как нужно
ИЛИ
public static void main(String[] args) {
        Bird eagle = new Bird();             - если укажем класс переменной именно Bird


Дочерний класс наследует методы, даже если в самом классе Bird их нет, и даже если сам обьект будет класса Bird:

public class Animal {
    public void fly(){                         - в старшем классе метод fly()
        System.out.println("FLYING");
_______________________________________
public class Bird extends Animal {             - пустой
_______________________________________
MAIN
public static void main(String[] args) {
        Bird eagle = new Bird("Eagle",12,3, 1500);
        eagle.fly();

Наследование конструктора:

abstract class Animal {
    String name;                                      - ОБЯЗАТЕЛЬНО должны быть созданы переменные для конструктор
    int age;
    int weight;

    public Animal(String name, int age, int weight){  - конструктор имеет 3 переменные
        this.name = name;                             - this. означает что переменные в параметрах этого обьекта и будут равны переменным сверху
        this.age = age;
        this.weight = weight;
    }


Общий принцип наследования:

public static void main(String[] args) {
       Animal eagle = new Bird();                    - 1) eagle может использовать методы которые есть ТОЛЬКО в классе старшем классе Animal
                                                     - 2) Если в классе Bird есть методы, переназначенные из старшего класса Animal, то выведутся именно значения Bird
                                                     - 3) Bird в такой записи(Animal класс) НЕ МОЖЕТ использовать свои УНИКАЛЬНЫЕ методы(к примеру fly())
                                                     - 4) Но мы можем сделать Downcast класса, только eagle будет иметь доступ к методам класса Bird
                                                     -    Downcast работает только с большего, на меньшее, со старшего на младший

Animal eagle = new Bird();                           - НЕ СРАБОТЕТ
eagle.fly();                                         - потому что метод fly() уникален для класса Bird, а наш обьект класса Animal                                   
 
Bird eagle = new Bird();                             - СРАБОТАЕТ 
eagle.fly();                                         - потому что обьект eagle теперь класса Bird, где есть метод fly()

Animal eagle = new Bird();                           - СРАБОТАЕТ 
((Bird)eagle).fly()                                  - потому что мы даункастили eagle класса Animal на дочерний класс Bird, где есть метод fly()  

Вывод:

Animal eagle = new Bird();
eat() - обший метод (есть только в классе Animal)
speak() - общий, но переопределен в Bird
fly() - уникальный для Bird

Когда мы старший класс ставим нашим определяющим
1) Обьект сможет выполнять ТОЛЬКО методы старшего класса или ОБЩИЕ методы, переопределенные в младшем
2) Обьект НЕ СМОЖЕТ выполнять УНИКАЛЬНЫЕ методы(типа fly())

eagle.eat();            - СРАБОТАЕТ, выдаст метод класса Animal (в Bird его нет)
eagle.speak();          - СРАБОТАЕТ, выдаст метод класса Bird (есть в Animal, переопределен в Bird)
eagle.fly();            - НЕ СРАБОТАЕТ, т.к метод уникален для класса Bird

PRIVATE внутри класса:

private String name = "Egor"       - private переменный можно использовать только ВНУТРИ КЛАССА, и они НЕ НАСЛЕДУЮТСЯ

private String getName(){          - private методы доступны только ВНУТРИ КЛАССА, и они НЕ НАСЛЕДУЮТСЯ
        return name;

Human egor = new Human();          - в Мейне
System.out.println(egor.getName);  - вот как используется private переменные, и как выводятся
OUTPUT
Egor



SPLIT 
String sentence = "I love my work";
String[] words = sentence.split("\\s+");     - этот метод делит на части стринги, использую ключ(в нашем случае пробел " ")
Вывод:
[I, love, my, work]                       - выводит массив из отдельных частей


Объявлять переменные сразу:

String test = "My name is George";
String name = test.split("\\s+")[3];
Вывод:
George




STRING BUFFER(Append), stringbuffer, string builder, stringbuilder

String                                   - не может сторить значения если они меняются где-нибудь в лупе, он всегда перезаписывает их заново
StringBuffer                             - это пустой стринг, в который мы можем добавлять значения через метдо .append(), и который может сторить значения за пределами лупа
.append(число или стринг)                - используется в StringBuffer для добавления значений в конец, всё сторится за пределами лупа как нужно
.insert(индекс, число или стринг)        - вставляет элемент на определенный индекс, сдвигаю другие элементы право
.reverse()                               - реверсит всю строку(очень полезно)
.replace(1,2,"egor")                     - ЗАМЕНИТЬ элементы с индекса(сейф) до индекса(второй он удалит) нашим элементом

РАЗНИЦА МЕЖДУ Buffer и Builder:
StringBuffer  - Thread-safe(поддерживает многопоточность), синхронизирeтся
StringBuilder - Not thread-safe(не поддерживает многопоточность), не синхронизируется

Пример:

public static void main(String[] args) {
    StringBuffer buffer = new StringBuffer();     - создаем обьект буфера
    String love = "I love my life";               - стринг
    String[] loveArr = love.split(" ");           - создаем из стринга массив, деля стринг на отдельные слова

    System.out.println(Arrays.toString(loveArr)); - на выводе будет массив из отдельных слов [I, love, my, life]
        
    for (int i = 0; i < loveArr.length; i++) {
        buffer.append(loveArr[i] + " ");          - из этого массива loveArr добавляем в буфер поочереди все слова, использую индексы массива[i] и форлуп
    }

    System.out.println(buffer);                   - выводом будет заново собранное предложение I love my life



































Threads, MultiThreading(Потоки)

                   
                                                     !!! Самое главное, и Deadlock в ПРОЕКТЕ (IMPORTANT) DeadLock, Explanation !!!


                                                              !!! ПРИМЕР В ПРОЕКТЕ "(TESTER) Multithread, ImageResizer" !!!

                                                        


                                                                 !!! ПРИМЕР В ПРОЕКТЕ (TESTER) Работа потоков наглядно !!!

Синхронизация применяется на Обьект Класса(если обычный метод), то есть "Только один поток может выполнять метод в обьекте этого класса"(лочится обьект) 
либо на Весь класс, то есть "Только один поток может выполнять метод внутри этого класса"(лочится весь класс)

Если в классе есть 2 или больше synchronized метода, то только один поток сможет выполнять ТОЛЬКО ОДИН МЕТОД одновременно, то есть


public synchronized void in();

public synchronized void out();          - если один поток зайдет в обьект выполнять один из этих методов, то лочится ВЕСЬ ОБЬЕКТ, больше одного потока одновременно в обьекте быть не может





















Различия Runnable и Callable(Runnable void, а Callable возвращает значение) - !!! Класс "ExecuteVsSubmit") !!!

Различия Executor и ExecutorService - !!! Класс "ExecutorVsExecutorService") !!! 

Различия execute() и submit() - - !!! Класс "ExecuteVsSubmit") !!!

Executor service                                                      !!! Пример в проекте "(IMPORTANT) ExecutorService & ThreadPools" !!!

Смотри в проекте или в видосе

Java ExecutorService - Part 1 - Introduction





















fork, join, ForkJoinPool, invoke, invokeAll, compute      !!! (TESTER) fork() join(), invoke(), invokeAll, compute() - ГРОКНУТЫ !!!
                                                          !!! (IMPORTANT) Web Crawler, fork() join(), ForkJoinPool, Recursive !!!

































IMPLEMENTS Runnable

ImageResizer resizer = new ImageResizer(subArray, newWidth, dstFolder, start, i + 1); 
new Thread(resizer).start();

ИЛИ

Thread thread = new Thread(new ImageResizer(subArray, newWidth, dstFolder, start, i + 1));
thread.start();





EXTENDS Thread

ImageResizer resizer = new ImageResizer(subArray, newWidth, dstFolder, start, i + 1);
resizer.start();


















Atomic variables, Атомарные переменные и многопоточность   

                                                        !!! Пример в проетке "(TESTER) AtomicVariables, Атомарные переменные" !!!



Атомарно - значит в одну операцию (на уровне процессора)

Атомарные переменные существуют для многопоточности

В примере ниже потоки будут бороться за операцию increment(), и пока в одном потоке только берется значение x и потом прибавляется, в другом потоке возможно эта единица уже прибавилась и значение увеличилось, а в пред потоке мы имеем более старое значние

Этот процесс неопределенности параллелизма называется - Race condition или Состояние гонки

Этот процесс происходит в Критических секциях (часть кода, который при выполнении несколькими потоками может работать неоднозначно)




                !!! ПРИМЕР !!!

public class Test{
    private static int x = 0;        - эта переменная будет инкрементироваться (не атомарная)

    public static void increment() { - метод инкремента
        x = x + 1;
    }

    public static int getX() {
        return x;
    }
}



public class Main {                                  - что происходит в мейне
    public static void main(String[] args) {

        for (int i = 0; i < 5; i++) {                - 5 раз вызываем новый поток
            new Thread(()->{                         - создаем через Лямбду
                for (int j = 0; j < 100000; j++) {
                    Test.increment();                - вызываем метод инкремента
                }
                System.out.println(Test.getX());     - выводим значение
            }).start();                              - стартуем поток
        }
    }
}


OUTPUT:

100000
217618
242899
342899               - как видим до 400.000 так и не дошел потому что иногда работал с устаревшими значениями переменной





А теперь создадим класс Test через Атомарную переменную

public class Test{
    private static AtomicInteger x = new AtomicInteger();  - создаем переменную

    public static void increment() {
        x.incrementAndGet();                               - метод incrementAndGet() у Класса AtomicInteger
    }
    public static int getX() {
        return x.intValue();
    }
}

























Volatile, кэширование переменнышб хэширование                   !!! Пример в проекте "(TESTER) Volatile variables" !!!

Слово volatiole в переменной защищает ее от кэширования

Если переменная присваивает одним потоком, а читается другим, то может случится такое:


























Synchronized метод, Синхронизированный метод          !!! Пример в проекте "(TESTER) Synchronized methods" !!!

ГРУБО ГОВОРЯ это слово засталяет метод работать в ОДНОПОТОЧНОМ РЕЖИМЕ (метод будут выполнять все потоки, но поочереди) 

Без слова synchronized метод работает параллельно из нескольких потоков с одной переменной

Synchronized обеспечивает одновременную работу метода только в одном потоке





Synchronized блоки                                     !!! Пример в проекте "(TESTER) Synchronized блоки" !!!

Если нас не пугает выполнение одного процесса(хоть и не совсем правильно) разными потоками, а пугают только ошибки с этим связанные, мы может сделать ПОТОКО-БЕЗОПАСНЫМ только БЛОК кода, а не весь метод















Чтобы сделать так, чтобы методы в программе выполнялись не поочереди, а одновременно друг с другом, нужно создать потоки:
1 Способ(лучший через интерфейс):

public class Test implements Runnable {       - Берем любой класс, и применяем к нему интерфейс Runnable
    public void run() {                       - создаем(переопределяем) метод run() в этом классе
        for(int i=1;i<6;i++){
            System.out.println("Number "+i);  - у нас это выводить числа от 1 до 6

public class Main {                           - это как использовать поток в мейне
    public static void main(String[] args) {
        Thread one = new Thread(new Test());  - создаем обьект класса Thread, определяем его как new Thread(new Test())
        one.start();                          - чтобы запустить поток, имя обьекта и метод start(), который один для всех потоков

Пример многопоточности:

Thread one = new Thread(new Test());          - создаем два потока от класса Test()
Thread two = new Thread(new Test());
one.start();                                  - запускаем оба потока
two.start();

Вывод:

Number 1                                      - как видно, потоки выполняются параллельно друг другу, а не поочереди
Number 1
Number 2
Number 2
Number 3
Number 3
Number 4
Number 5
Number 4
Number 5


2 Способ(понятнее через наследование класса Thread):

public class Option2 extends Thread{               - создаем класс Option2, наследующий от Thread
    public void run(){                             - переопределяем метод run()
        for(int i=1;i<6;i++){
            System.out.println("Number "+i);       - выдает числа от 1 до 5

public class Main {
    public static void main(String[] args) {
        Option2 two = new Option2();               - просто создаем обьект нашего класса Option2
        Thread one = new Thread(new Option1());    - это создание обьекста из 1 способа
        one.start();
        two.start();                               - запускаем их абсолютно одинаково, они делают по сути то же самое

Приемущство 1го способо в том, что интерфейсов можно добавить в класс сколько угодно, а наследновать класс может только от одного другого



















































Все виды массивов и их различия(Collections, Array[], ArrayList, List, HashMap), Коллекции

                    Collections
                     /       \
                    /         \
                  List        Set



Collections - АБСТРАКТНЫЙ класс, от которого наследуют все коллекции

List  - любые элементы, с индексами, медленнее (ArrayList, LinkedList)
Set   - только уникальные элементы, без индексов, супер быстрый (Hash, Tree)
Map   - <ключ, значение>, ключи уникальны (Hash, Tree)     

ArrayList           LinkedList
           <- get
            remove ->
             add ->


        
  Tree                 Hash
            fast ->
        <- sorted



List - ОСНОВНОЙ ИНТЕРФЕЙС для ArrayList, LinkedList, они его субклассы.

ArrayList - в него можно вставлять сколько угодно элементов, он диначмически увеличивается, доступ к элементам поиндексный, и он лучше в динамических действиях где нужен доступ к разным частям массива, к примеру он лучше в сортировках.

LinkedList - то же самое что и ArrayList, но у него доступ к массиву только с начала или с конца, как бы по цепочке, поэтому он быстрее во вставках или удалении элементов, но медленнее по простому доступу по индексу.

ArrayList vs LinkedList:
Linked быстрее для удаления и добавления элементов с начала или конца, ArrayList быстрее для доступа по индексу

Set - ОСНОВНОЙ ИНТЕРФЕЙС, только УНИКАЛЬНЫЕ элементы, нет метода get()

HashSet - НЕУПОРЯДОЧЕННАЯ коллекция УНИКАЛЬНЫХ элементов, чтобы получить отдельный элемент можно использовать только итератор
LinkedHashSet - ЗАПОМНИТ ПОРЯДОК, в котором были добавлены элементы
TreeSet - УПОРЯДОЧЕННЫЙ

.remove() - удаляет только по значению, т.к нет индексов, удобно для чисел, хорош для хранения id и других уникальных данных

HashMap - любое количество элементов, но с УНИКАЛЬНЫМИ КЛЮЧАМИ


HashSet - БЫСТРЫЙ, НЕ УПОРЯДОЧЕННЫЙ, быстрее всех в поиске элементов(.contains всегда 1 ms) 
TreeSet - МЕДЛЕННЕЕ, но УПОРЯДОЧЕННЫЙ






















































LIST, Arraylist, Листы(именно лист, именно list)

ВАЖНО! Обьявлять тип переменной именно List(то есть тип интерфейса), а не ArrayList(одна из реализаций этого интерфейса)

List people = new ArrayList<>(Arrays.asList(здесь любой array[] тип)), например:
List people = new ArrayList<>(Arrays.asList(words)) - создать лист из String[] массива words
List people = new ArrayList<>(Arrays.asList(scanner.nextline().split(" "))) - создать лист из инпутов, который разделит слова через пробелы

List people = new ArrayList();               - в таком можно записывать любые обекты(числа, стринги и тд)
List<Integer> people = new ArrayList<>();    - здесь только числа
List<String> people = new ArrayList<>();     - здесь только стринги
List<Animal> people = new ArrayList<>();     - здесь только ОБЬЕКТЫ КЛАССА Animal(так тоже можно)


Быстрая инициализация:

List<String> arrList = new ArrayList<>(){{   - здесь именно ДВОЙНЫЕ скобки {{add}} 
    add("first item");
    add("seconds item");
    add("third item");
}};


Методы:

people.add()               - добавить элемент в конец списка
people.add(0, "bear")      - НЕ УДАЛЯЯ элемент на индексе 0, добавить туда стринг "bear", сдвигая все отсальное вправо
people.set(0, "cat")       - ЗАМЕНИТЬ элемент на индексе 0 на стринг "cat"
people.get(2)              - выдаст обьекст на индексе 2 (к примеру "bear")
people.indexOf("cat")      - выдаст на каком индексе стоит ПЕРВЫЙ попавшийся обьект "cat"
people.lastIndexOf("cat")  - выдаст на каком индексе стоит ПОСЛЕДНИЙ попавшийся обьект "cat"
people.contains("cat")     - выдаст true/false, показывает есть ли этот элемент в списке или нет
people.size()              - выдаст размер листа
people.clear()             - полностью очистить список   
people.sublist(1, 5)       - как и .subString печатает определенную часть листа

            
people.remove(2)                                  - удалить обьект на индексе 2
people.remove("cat")                              - удалить первый попавшийся текстовый обьект "cat" с первого попавшегося индекса, где он находится
letters.removeAll(Collections.singleton("cat"));  - удалить все текстовые обьекты "cat" со всех индексов 
people.remove(4)                                  - если хотим удалить САМО ЧИСЛО 4, а не что-либо с идекса 4, то нужно сделать следующее...

С числами работает по другому:

ArrayList<Integer> numbers = new ArrayList<>();   - создаем лист
numbers.add(15);                                  - добавляем числа
numbers.add(56);

numbers.remove(15);                               - НЕ СРАБОТАЕТ, он попытается удалить число с 15 индекса
numbers.remove(Integer.valueOf(98));              - СРАБОТАЕТ, удалит первое попавшееся число 98
numbers.removeAll(Arrays.asList(98));             - СРАБОТАЕТ, удалит все числа 98 из списка
numbers.removeAll(Arrays.asList(98,12));          - СРАБОТАЕТ, можно добавлять столько числео сколько хочешь, он удалит все


Как записать инпут в ArrayList со сплита(ArrayList split):

String sentence = scanner.nextLine();     - наше предложение на ипуте
ArrayList<String> words = new ArrayList<>(Arrays.asList(sentence.split(" ")));  - sentence.split создает массив String[], поэтому мы кастим его в ArrayList
                                                                                - с помощью Arrays.asList, в конце концов получаем рабочий лист из сплита
ArrayList<String> letters = new ArrayList<>(Arrays.asList(words.get(2).split(""))); - так как метод split работает только на стринги, то чтобы поделить
                                                                                    слова на отдельные буквы, используем words.get(2).split("") 





































Regex, regular expressions, Matches, регулярные выражения(password validation)

Применяется к стрингу, чтобы понять есть ли в стринге определенные элементы, выдает булин true/false

\\d  - любое число(по дефолту смотрит на первом индексе) = [0-9]
\\D  - любвей элемент, но не буква = [^0-9]
\\w  - любая буква или число = [a-zA-Z0-9_]
\\W  - любой элемент, но не буква или число = [^a-zA-Z0-9_]
\\s  - пробелы и переносы строки = [\r\n\t\f\v ]
\\S  - любой элемент, но не пробелы и переносы строки = [^\r\n\t\f\v ]
.    - точка означает ЛЮБОЙ элемент до выбранного(.\\d) или после выбранного(\\d.) элемента(в нашел случае \\d - число) = 

*      - означает 0 или БЕСКОНЕЧНОЕ МНОЖЕСТВО = {0,} относится к пред. элементу (\\d+) [a-z]+
+      - означает 1 или бесконечное множество = {1,} 
?      - означает 0 или 1 раз = {0, 1}
(-| )  - означает - ИЛИ пробел, важен символ |   
[a-z]  - так записывается элемент в диапозоне этих букв, грубо говоря любая буква
[A-Z]  - а это в верхнем регистре
[^a-z] - знак ^ ИМЕННО В [] означает отрицание, то есть НЕ буквы от a-z 
\\d\\d - 2 числа подряд 

^   - знак начала строки(до него нет ни пробела, ничего вообще)
$   - знак конца строки (грубо говоря перед \n)
\b  - границы слова(грубо говоря разделенные пробелами или запятыми и тд) \b\d{3}\b = найти все слова которые выглядят как ТОЛЬКО 3 буквы подряд, например (386, 787), но (цифра675) - не подойдет
\B  - НЕ граница
















ГРУППЫ (Очень полезно):

$1  - 1я группа, которую ты обозначил скобками ()

Пример:
String asd = "Hello 3 people";
String result = asd.replaceAll("\\w+ (\\d+) \\w+", "$1");
Вывод:
3

Полезный пример:
Обрежет номер правильно, даже если между цифрами нет пробелом, есть, или там тире, сколько угодно раз

String number = "aasd 7 999475 11-38 ash776";
String result = number.replaceAll(".*(\\d)(\\s*|-*)(\\d{3})(\\s*|-*)(\\d{3})(\\s*|-*)(\\d{2})(\\s*|-*)(\\d{2}).*",
                "+$1-$3-$5-$7-$9");
Вывод:

+7-999-475-11-38




ПРИМЕР:
String line = "asd1"; - число после букв
line.matches("\\d.*") - НЕ СРАБОТАЕТ. т.к он смотрит только ПОСЛЕ числа, читается так(TRUE если сначала идет цифра, а потом что угодно)
String line = "1asd"; - число до букв
line.matches(".*\\d") - НЕ СРАБОТАЕТ. т.к он смотрит только ДО числа(TRUE если начинается с чего угодно, но заканчивается на числе)
String line = "asd1asd"; - быквы со всех сторон от числа
line.matches(".*\\d.*") - СРАБОТАЕТ. т.к он смотрит только и ДО и ПОСЛЕ числа(TRUE если начинается с чего угодно, где-то встречает хотябы одно число, и дальше заканчивается чем угодно).

Если нам для пароля нужно, чтобы было минимум 2 числа в любом месте в любой последовательности, это будет записываться так:

line.matches(".*\\d.*.*\\d.*") - любой элемент до числа, потом любой элемент после числа, и потом то же самое для второго числа


.*\\d.* - означает выдать true, если число(или другой элемент) есть в любой части стринга


line.matches(".*[a-z].*") - так записывается, что должна быть хотябы одна буква, в любой части стринга
line.matches(".*[!@#$%&*].*) - в [] можно вписать любые элементы, без запятой, которые должны повториться хотябы раз в любой части, для 2 раз вот так:

password.matches(".*[!@#$%&*].*.*[!@#$%&*].*") - означает TRUE только если будет 2 таких символа где-то в пароле

Так будем опреледять номер телефона:

String line = "2-13-56";
System.out.println(line.matches("\\d-\\d\\d-\\d\\d")); - тир\ и остальные знаки можно писать как есть
Вывод: 
TRUE








































Collections

Мощный и удобный инструмент для работы со списками и массивами.
ArrayList<String> words = new ArrayList<>(Arrays.asList(scanner.nextLine().split(""))) - создаем лист и делим слова на отдельные буква

Collections.sort(words)    - отсортировать в алфавитном или числовом порядке
Collections.reverse(words) - реверсивно поменять последовательность(ПОЛЕЗНО)
Collections.max(words)     - макс значение
Collections.min(words)     - мин значение
Collections.shuffle(words) - перемешать в рандомном порядке




Горячие клавиши (Shortcuts, Hotkeys)

CTRL+R        - regex тренировка(ОЧЕНЬ ПОЛЕЗНО)
CTRL+P        - посмотреть параметры у функции, к примеру StringBuilder() <- что может быть в этих скобочках
CTRL+Insert   - выделить всю строку
CTRL+ALT+L    - переместить код на нужные места(по стилю)
CTRL+SHIFT+/  - закомментировать выбранную строку
ALT+INSERT    - вставить Getter, Setter, Constructor, а также переназначить методы от суперкласса
CTRL+O        - Override, переназначить методы из суперкласса
SHIFT+F4      - закрыть окно вывода(сам назначил)
CTRL+H        - дерево наследования классов(зависимости)

Mac
CTRL+ENTER    - вставить Getter, Setter, Constructor, а также переназначить методы от суперкласса
COM+P         - посмотреть параметры у функции, к примеру StringBuilder() <- что может быть в этих скобочках
OPTION+COM    - переместить код на нужные места(по стилю)
CTRL+SHIFT+/  - закомментировать выбранную строку
CTRL+O        - Override, переназначить методы из суперкласса
CTRL+H        - дерево наследования классов(зависимости)
FN+DELETE     - Delete с Винды
OPTION+COM+<- - предыдущее положение каретки



 

Карта методов, основные методы:
Переменная test

.toString():
[]              = Arrays.toString(test) -> "[Hello Worlds]"
Buffer          = test.toString()
List            = test.toString()

.split():
String          = test.split(" ")

.matches():
String          = test.matches("\\d")

.replace():
String          = test.replace(" ","")

Arrays.asList(?):
String
int
[]
Buffer

.indexOf("str")
String        = test.indexOf()
Buffer        = test.indexOf()
[]            = Arrays.asList(test).indexOf()
list          = test.indexOf()

.atIndex(i)
String        = test.charAt(i)
Buffer        = test.charAt(i)
[]            = test[i]
List          = test.get(i)




Принципы ООП собеседование:

1)Приемущства ООП парадигмы: 
ООП парадигма позволяет нам переложить обьекты из реального мира в наш код, так что когда мы пишем нашу программу мы устанавливаем связи и взаимодействия между обьектами подобно тому, как они взаимодействуют в реальном мире. Из-за этого улучшается восприятие нашего кода и программы, а также кода другого человека, потому что концепт работы программы имитирует концепты из реальной жизни.

2)Недостатки ООП парадигмы: 
Избыточность. Когда мы хотим достигнуть какой-то простой цели, мы не хотим описывать всю структуру обьектов, связи между ними, думать о том как они должны взаимодействовать между собой, мы просто хотим получить какой-то конечный результат из нашей программы и не хотим добавлять всего этого Overhead'a. Грубо говоря не хватает краткости 

3)Инкапсуляция: 
(ПРАВИЛЬНОЕ ОПРЕДЕЛЕНИЕ) - Это механизм языка, позволяющий обьеденить данные и методы, работающие с этими данными, в единый обьект, и скрыть детали реализации от пользователя.

Инкапсуляция позволяет нам защитить наш обьект от неправильного использования, путем модификаторов доступа. 
Пример: если мы хотим добавить поле, которое будет обозначать дату создания обьекта, и мы инициализируем её в конструкторе, то если мы не закроем это поле путем модификаторов доступа, любой программист сможет использовать это поле для того чтобы изменить эту дату, или просто удалить её, из-за чего цель обьекта теряется.
Использую модификаторы доступа мы зыщищаем наши обьекты от неправильного использования, но оставляем их открытыми для расширения.

4)Наследование:
Наследование - это когда один обьект приобритает характеристики другого обьекта, добавляя свои собственные.
Пример: Музыкальный инструмент - у него есть поле диапозон нот и метод издать звук, а есть подкласс Гитара, у которого есть поле количество струн и форма гитары, методы играть перебором и играть армейским боем.

5)Полиморфизм:
Полиморфизи позволяет использовать одно имя метода, для выполнения общих для класса действий.
Пример: интерфейс Bird, у которого метод fly(), но сокол будет летать по своему, голубь будет летать по своему.   

6)Абстракция данных:
Абстракиця данных - это выделение значимых характеристик обьекта.
Пример: К примеру Студент - значимые характеристики у него будут оценки, кафедра, специальность и курс, нам не так интересно цвет волос, глаз, рост и тд. Это уже характеристики, которые не относятся к нашей программной системе.

7)Позднее и раннее связывание:


ООП и всё что с ним сзязанно

Сабкласс может наследовать метод от суперкласса, но изменять лишь его часть, путем использования слова super:
public void run(){
	super.run();
	sout("Run like a dog")
} 

private методы и переменные не наследуются

Применять наследование ТОЛЬКО если применимо правило IS-A(Ford is a car, Tea is a beverage)

Причина делать переменную и сам обьект разными классами? Animal dog = new Dog()
Мы можем сделать массив из всех сабклассов от Animal
Animal[] animals = new Animal[3]
animals[0] = new Dog();
animals[1] = new Cat();
animals[3] = new Tiger();
И вызвать их методы(возможно ПЕРЕНАЗНАЧЕННЫЕ) поочереди:
        for (Animal oneOfAnimals:animals) {
            oneOfAnimals.eat();
        }
		
ОДНАКО!!!
На такие классы НЕ РАБОТАЮТ ИНТЕРФЕЙСЫ, чтобы задейстовать метод ИНТЕРФЕЙСА который есть у DOG, но нет у ANIMAL, нужно обозначить переменную тоже Dog
Dog dog = new Dog();
		
Классы не могут быть PRIVATE, но если не обозначить класс как PUBLIC, то он будет доступен для наследования только классам в своем package, 
короче говоря NON-PUBLIC классы могут быть наследованны только в своей папочке.

FINAL класс не может быть наследован, final и означает, что дерево наследований закончено, и больше от этого класса дальше наследовать нельзя

Также final можно обозначить метод, и его больше не смогут Override, переназначить

Override мутоды(переназначенные) должны сохранять return type(тип возврата) и аргументы:
boolean turnOn()           - оригинал
int turnOn()               - НЕЛЬЗЯ, изменен return type
boolean turnOn(int number) - НЕЛЬЗЯ, изменен аргумент(это больше не Override а Overload)

Метод при наследовании может стать более открытым(public) или остаться таким же, но не может стать более закрытым(private)

Override Contract - return type и аргументы должны быть одинаковы(и ещё доступ такой же или открытей)



Overloading:

Overloaded метод - это несколько методов с одним именем, но разными аргументами и return type.
Пример Overloaded метода:
ArrayList list
list.remove(int index)  - здесь удаляет обьект по индексу в листе 
list.remove(Object 0)   - а здесь по названию самого обьекта, и находит его индекс и удаляет, хотя название такое же, remove()

Чтобы Overload наш метод, мы ОБЯЗАНЫ изменить параметры метода(аргументы которые пишем в круглые скобки), изменить только return type недостаточно

Overloaded метод - это НЕ ПОЛИМОРФИЗМ

Доступ к разным Overloaded методам может быть любой(может различаться)













ТИП ПЕРЕМЕННОЙ variable type


                 
                     Alive alive = new Human();
                      /                   \
                     /                     \
Доступные методы и переменные отсюда    Реализация этих методов отсюда    







Если мы используем в качестве ТИПА переменной Интерфейс, Абстрактный класс или просто Родительский класс, то переменная будет иметь
только методы и переменные ТИПА ПЕРЕМЕННОЙ, но с реализацией типа ОБЬЕКТА

Alive alive     = new Human(); - Абстрактный класс
Sapiens sapiens = new Human(); - Просто суперкласс
Human human     = new Human(); - Сам класс
Walkable walker = new Human(); - Интерфейс


human.beAlive();       - сработают все методы
human.beSapiens();
human.beHuman();
human.walk();


alive.beAlvie();       - сработает только переназначенная версия метода из Абстрактного класса beAlive()
alive.beSapiens();
alive.beHuman();
alive.walk();











































Функциональный интерфейс Functional Intefrace, Лямбда выражения lambda expressions, Анонимные Классы

Функциональный интерфейс - интерфейс с ровно 1 абстрактным методом

Анонимные Классы - классы, которые мы не создаем как отдельные классы, а может вписать прямо в метод для выполнения одной определенной задачи, грубо говоря служит для сокращения кода

Лямбда выражения - сокращенная запись анонимных классов






Анонимные Классы:

Отсортируем коллекцию работников по зарплате, Comparator пример:


Collections.sort(staff,                                          - staff это переменная обьекта "работник"
        new Comparator<Employee>() {                             - Анонимный класс с именем интерфейса
    public int compare(Employee o1, Employee o2) {               - метод этого интерфейса, который мы реализуем
        return Integer.compare(o1.getSalary(), o2.getSalary());  - сама реализация с логикой которая нам нужна
    }
});









Лямбда выражения


Lambda форма:

(параметры метода) -> {реализация метода}

самая короткая запись:
() -> {}


Collections.sort(staff, (o1, o2) ->                        - o1 и o2 параметры для метода Comparator, если параметров нет, то пишутся пустые скобки()
        Integer.compare(o1.getSalary(), o2.getSalary()));  - реализация метода




Collections.sort(staff, (o1, o2) ->                         - так записывается если нужно реализовать больше одного оператора(больше 1 условия return)
{                                                           - код обрамляется {} скобками
    return Integer.compare(o1.getSalary(), o2.getSalary()); - и обязательно должно быть return
});










Stream API


Методы stream:

stream   - метод класса Collection, стримит все элементы коллекции
forEach  - делает какое-то действие для каждого элемента
filter   - фильтрует элементы по какому-то признаку(возвращает boolean)
sorted   - сортирует (принимает Comparator)
max      - выводит максимальное значение (принимает Comparator)
min      - выводит минимальное значение (принимает Comparator)
average  - выводит среднее арифметическое (нужно чтобы перед этим была функция mapToInt)
reduce   - привести весь массив к одному значению (на выходе получаем объект Optional)
flatMap  - почти то же самое, что map, только он "выравнивает" данные, грубо говоря он нужен чтобы получить Stream внутри другого Stream'а, нужен когда у нас есть лист в листе
map      - преобразовать данные, чтобы после этого метода работать не с обьектом коллекции, а к примеру с int - его возрастом или String - именем
mapToInt - преобразовать в int (нужно для average)
mapToDouble - преобразовать в double
collect  - собрать элементы в лист (коллекцию)






Из чего создаются Stream:

Array[]   - Arrays.stream(person.getArr());
List      - person.getList().stream();
Map<K,V>  - person.getMap().keySet().stream(); - из набора ключей или значений
Set       - person.getSet().stream();









I/O методов Stream API
  
        Input              Method                 Output
       

      Collection <any>     stream()              Stream <any>

       Stream <>          forEach -> any            any

       Stream <>            map -> any           Stream <any>

       Stream <>          collect -> any         Stream <any>

       Stream <any num>   max(min)               Optional <any>

      (Int)Stream          average               OptionalDouble
    







Создание стрима Integer:

Stream<Integer> stream = Stream.of(1, 2, 3); - через метод Stream.of()

int[] arr = {1, 2, 3};                       - создаем массив
Arrays.stream(arr);                          - через Arrays.stream() превращает тип обьекта в Stream
Stream<Integer> stream = Arrays.stream(arr); - ну и можно по желанию присвоить объекту переменную



Создание бесконечного стрима:

Stream.iterate(1, n -> n + 1).forEach(System.out::println); - так

Stream.generate(()->"aaa").forEach(System.out::println);    - или так












forEach:

people.stream().forEach((p)->{   - это грубо говоря сокращение цикла "for i" для перебора всех элементов, только через лямбду 
    System.out.println(p);       - здесь p является как параметром лямбды, так и параметром println, значит его можно сократить то такой записи:
});


people.stream().forEach(System.out::println); - если параметр лямбы является параметром метода, то можно сократить до вот такой записи











filter:

people.stream().filter((p) -> p.getAge() > 11).forEach(System.out::println); - мы в одной строкой фильтруем наши обьекты по признаку "больше 18 лет" и выводим их в консоль














sorted:

people.stream().
        sorted((o1, o2) -> {                              - сортирует по имени и вы водит все в консоль
            return o1.getName().compareTo(o2.getName());
        }).
        forEach(System.out::println);



people.stream().
        sorted(Comparator.comparing(People::getName)).  - сортирует через метод Comparator.comparing для сокращения записи
        forEach(System.out::println);












average:

list.stream()
       .mapToInt(human -> human.getAge())
       .average()
       .ifPresent(System.out::println);













map:

people.stream().
        filter((p) -> p.getAge() > 4).                    - фильтруем по возрасту 
        sorted((o1, o2) -> {                              - сортируем по имени
            return o1.getName().compareTo(o2.getName());
        }).
        map((p) -> p.getAge()).                           - преобразуем объект "p" в int - его возраст(можно и имя)
        forEach(System.out::println);                     - распечатаются только числа возрастов теперь

или сокращенно

people.stream().
        filter((p) -> p.getAge() > 4).                    
        sorted((o1, o2) -> {                              
            return o1.getName().compareTo(o2.getName());
        }).
        map(People::getAge).                                   - сокращенно                      
        forEach(System.out::println); 









reduce:

Допустим нужно выбрать людей, которым больше 18 и сложить их возраст в одно число



people.stream()
                .filter(p->p.getAge() > 18)       - фильтруем
                .map(People::getAge)              - превращаем тип данных в int от возраста людей(это очень важно для метода reduce)
                .reduce((p1,p2) -> p1+p2)         - складываем все возраста в одно число (на выводе Optional) 
                .ifPresent(System.out::println);  - IfPresent метод обьекта Optional, где говорим если объект есть, то выводим в консоль out












collect:

Нужно из класса Аэропорт -> Терминалы -> Полеты сделать лист полетов (собрать в лист)

collect - на вход принимает Stream<>

.collect (Collectors.toList()) - форма



List<Flight> flightsList = airport.getTerminals().stream()  "Stream <Terminals>"
                .ma p(t -> t.getFlights())                   "Stream <List <Flights> >"
                .flatMap (f -> f.stream())                   "Stream <Flights>"
                .collect (Collectors.toList());              "List <Flights>"            - вот мы собрали все через метод collect в List








flatMap:

Нужно из класса Аэропорт -> Терминалы -> Полеты сделать лист полетов (собрать в лист) и добиться типа данных "Stream <Flights>" перед тем как .collect в "List <Flights>"

Он нужен когда у нас есть лист внутри самого листа, и нужно его тоже перебрать и что-то сделать с данными, допустим сделать из них массив, в остальном используется просто map


List<Flight> flightsList = airport.getTerminals().stream()   "Stream <Terminals>"
                .map (t -> t.getFlights())                   "Stream <List <Flights> >"
                .flatMap (f -> f.stream())                   "Stream <Flights>"          - он как бы "сокращает" вложения, то есть мы убрали List с предыдущего преобразования 
                .collect (Collectors.toList());              "List <Flights>"


сравнение с map:

List<Flight> flightsList = airport.getTerminals().stream()   "Stream <Terminals>"
                .map (t -> t.getFlights())                   "Stream <List <Flights> >"
                .map (f -> f.stream())                       "Stream <Stream <Flights> > " - он просто преобразовал List в Stream внутри самого Stream, но не сократил 
                .collect (Collectors.toList());              "List <Flights>"




































Интерфейсы Interfaces


              Interface                  Subclass

                               
          Abstrcact methods    -!->

            Static methods     -!->

               variables        -->
              
              instantiate       NO

             variable type     YES


-!->    - значит обязан его переназначить

-->     - значит передает доступ

instantiate - можно ли создать обьект этого класса

variable type - можно ли использовать как тип переменной



                         Тип переменной

           Abstract class                Subclass
 
                               
                 X-    Abstrcact methods   -X
             
                 <--   Overriden methonds

                 <--       variables




Могут иметь только abstract и static методы

В интерфейсах нет модификаторов доступа

Нет переменных(хотя вообще-то есть)

variable type - если использовать как тип переменной, то обьект сможет использовать только методы и переменные интерфейса, которые были переназначенны в классе который implemented этот интерфейс

Можно implement сколько угодно Интерфейсов, но наследовать только от одного класса
Пример:
public class Human implements Walkable, Speakable

Абстрактные классы не обязаны implement методы интерфейсов, но обязан будет первый solid наследник







































Абстрактные классы Abstract class

                                                 
                         Наследование

           Abstract class             Subclass
 
                               
          Abstrcact methods   -!-> 

            Static methods    -!->
              
               methonds        -->  

               variables       -->

              instantiate       NO

             variable type     YES




-!->    - значит обязан его переназначить

-->     - значит передает доступ

instantiate - можно ли создать обьект этого класса

variable type - можно ли использовать как тип переменной



                         Тип переменной

           Abstract class                Subclass
 
                               
                 X-    Abstrcact methods   -X
             
                 <--   Overriden methonds       

                 <--       variables      

           

variable type - будет иметь только методы АБСТРАКТНОГО КЛАССА, переназначенные сабклассом, и только свои переменные


Абстрактный класс по сути обычный класс, кроме того, что из него нельзя сделать обьект.
Но если есть хотябы один ABSTRACT метод, то и КЛАСС ТОЖЕ обязан быть ABSTRACT

Но в абстрактном классе МОГУТ БЫТЬ И АБСТРАКТНЫЕ И ОБЫЧНЫЕ МЕТОДЫ

Если нам нужен класс, только для того, чтобы от него наследовали методы и переменные, но мы не хотим ОБЬЕКТЫ этого класса, то мы можем сделать этот
класс АБСТРАКТНЫМ.

Его невозможно инициализировать(instantiate) как обьект.
Но его можно использовать как Тип переменной Animal dog = new Dog(); - в основном для этого и используют абстрактные классы, когда хотим использовать
его как Тип переменной для обьединения сабклассов для какого-то действия(массив и тд), но хотим чтобы его нельзя было создать как обьект.

Абстрактный класс СОЗДАН ДЛЯ ТОГО ЧТОБЫ ОТ НЕГО НАСЛЕДОВАЛИ, сам по себе он ничто и никто, он просто шаблон для наследования.

PUBLIC модификатор нужен для переменных, чтобы к ним был доступ у сабклассов из других папочек(packages), 
если суперкласс и сабкласс в одной папке c мейном и друг другом, то сабкласс может пользоваться переменными без модикифатора public

ПЕРВЫЙ Сабкласс ABSTRACT суперкласса ОБЯЗАН вписать в себя ВСЕ АБСТРАКТНЫЕ МЕТОДЫ суперкласса и дать им тело

ABSTRACT МЕТОДЫ - обязаны быть переназначены сабклассами, ОБЫЧНЫЕ МЕТОДЫ - не обязаны, а сабкласс их просто будет иметь
















FINAL метод нельзя переопределить у сабклассов

FINAL переменную нельзя никак поменять(изменить или дополнить), их пишут ЗАГЛАВНЫМИ БУКВАМИ

FINAL для класса означает что от него ДАЛЬШЕ НЕ МОГУТ БЫТЬ САБКЛАССОВ


Static классов НЕ БЫВАЕТ(но можно в теории этого добиться если сделать Private конструктор и сделать все методы и переменные static)

Static методы доступны без создания обьекта и могут использовать только static переменные(при обращении к обычной instace variable, метод не знает ЧЬЯ ЭТО ПЕРЕМЕННАЯ? КАКОГО ОБЬЕКТА? Ведь обычные переменные к классе отностятся к ОПРЕДЕЛЕННОМУ ОБЬЕКТУ и у каждого обьекта могут быть РАЗНЫЕ)

Static переменные - это переменные КЛАССА(переменная одна на ВЕСЬ КЛАСС, меняешь её она меняется в абсолюте, у всех обьектов)
Обычные переменные - это переменные ОБЬЕКТА






Все классы наследуют от ГЛАВНОГО КЛАССА в Java, это класс Object, у каждого класса есть 4 метода:
hashCode()
getClass()
equals()
toString()





ENUM

Они создаются как классы и выглядят вот так:

public enum CatColors {
    WHITE,
    BLACK,
    BROWN,
    STRIPED,
    GINGER
}

В классе можно их использовать вот так:

public void setCatColor(CatColors color){ - метод для назначения 
}

Вот как это будет выглядеть в программе:

public static void main(String[] args) {

    Cat cat = new Cat();
    cat.setCatColor(CatColors.BROWN);
}

Добавление библиотек:

Библиотеки принято держать в папке lib

File -> Project -> Structure -> Libraries -> +



Примитивы против Обьектов:
1) Примитивы содержат в себе сами значения, а переменные обьектов лишь ссылки на них
	Cat cat = new Cat();	
	cat1 = cat; - здесь обе переменные будут менять один обьект
	но
	int number = 12;
	int number1 = number;
	int number1 = number1 + 6; - здесь это разные значения, number1 будет равен 18

2) У примитивов есть default значения, а обьекты обязательно нужно инициализировать

Boxing и Unboxing:
Примитив -> Обьект   = Боксинг   - это когда примитив воспринимается(кастится) как обьект для каких-то целей
Обьект   -> Примитив = Анбоксинг - наоборот, когда обьект воспринимается как примитив для чего-то

Пример:

Integer age = 10; - Обьект
int count = 17;   - Премитив
System.out.println(age > count); - чтобы выполнить это, Java анбоксила age в примитив
false














Кодировки текста:
У char есть свой код, чтобы его узнать можно ввести:

char x = 'x';
int xCode = x;
System.out.println(xCode);
120                          - это код буквы x


Всё идет к единой кодировке(Unicode)самая известная кодировка это UTF-8
Java работает UTF-8












Время, дата, календарь и тд(Date, DateFormat, Calendar)


Calendar   ->   Date   ->   long     
        .getTime   .getTime


Выводы:

Calendar - [time=1591368749036,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar......
Date     - Fri Jun 05 21:52:29 CXT 2020
long     - 1591368749083



System.currentTimeMillis()        - показать текущее время в миллисекундах(сколько прошло с 1970г), можно поставить в начале и конце, чтобы узнать скорость выполнения задачи

Calendar calendar = Calendar.getInstance()            - создать инстанцию календаря

Calendar calendar = new GregorianCalendar()           - создать Грегорианский календарь(он лучше)

System.out.println(calendar.getTime())                - вывести время

calendar.setTimeZone(TimeZone.getTimeZone("UTC"));    - установить часовой пояс


   

calendar.add(Calendar.YEAR, 3)                        - добавить к текущей дате 3 года(также можно менять секунды, месяцы, недели и тд) 

calendar.set(1994, Calendar.DECEMBER, 12)             - установить дату, и на ней уже можно узнать какой был день недели, и все остальное

calendar.set(Calendar.DATE, calendar(Calendar.DATE) + 30) - быстро установить определенное поле






Сравнение дат и времени

Calendar cal = Calendar.getInstance();

if (cal.get(Calendar.YEAR) == 2017){        - так моно сравнивать время, через календарь

}









DateFormat, SimpleDateFormat

DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss") - некий конструктор для отображения даты(упрощенный)
Date date = new Date()                                              - отображает текущую дату и время в формате "Sat May 23 19:55:33 CXT 2020"
System.out.println(dateFormat.format(date))                         - использование DateFormat, отобразится как "23/05/2020 20:07:42"

DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT); - обычный DateFormat



Программа определяющая какой был день недели в каждое твое день рождение:

DateFormat dateFormat = new SimpleDateFormat("d/M/y EEEE");                  - создает упрощенный формат даты, где EEEE выдает день недели
Calendar calendar = Calendar.getInstance();                                  - создаем обьект календаря(инстанцию)
for (int i = 1994, j = 0; i < 2021; i++, j++) {                              - цикл по всем годам, j - для подписи какой др по счету
     calendar.set(i, Calendar.DECEMBER, 12);                                 - устанавливает календарь на 1994 год и мой др
     System.out.println(j + " - " + dateFormat.format(calendar.getTime()));  - ну и принтим эту дату в парвильном, упрощенном формате
}



















Decimal Format(DecimalFOrmat, форматирование чисел)

Decimal -> String
    conversion

Создание:

Double temp = 36.789645;

DecimalFormat decimalFormat = new DecimalFormat("0.0°C "); - здесь пишем формат в который будут приводится числа
String tempFormatted = decimalFormat.format(temp);
System.out.println(tempFormatted);

Вывод:
36.7°C


Printf(форматирование чисел через %)

Форма:

Double temp = 36.789645;
System.out.printf("%.1f" + "°C" + " ", temp) - после запятой можно ставить несколько переменных

Вывод:
36.7°C


%d   - обычнео целое число
%f   - дробное число с точкой(float и double)
%s   - строка
%S   - строка в UPPERCASE
%c   - символ(char)
%C   - символ в UPPERCASE
%b   - булин(true или false)


1$   - указатель на 1ю переменную (%1$d - %всегда в начале, потом номер переменной, потом $, потом тип переменной d) 
%.2f - указать кол-во цифр после точки в float и double
%.2s - работает со троками, печатает только первые 2 символа строки
%5d  - задать МИНИМАЛЬНЫЙ размер числа, если это значение больше числа, добавит пробелы ПЕРЕД ним(   56)
%-5d - добавит пробелы ПОСЛЕ числа(56   )
%05d - то же самое, только заполняет нолями(00056) 
%,d  - запятая разделяет по тысячам(1 856 654)



Работа с несколькими переменными:

System.out.printf("int = %d float = %f", intNumber, floatNumber)      - если как здесь переменные стоят в порядке появления в строке, то можно не указывать номер переменной,(%d %f, intNumber, floatNumber)

System.out.printf("int = %2$d float = %1$f", floatNumber, intNumber); - если переменные стоят не в порядке их использования в строке, то нужно указывать номер переменной через 1$ и 2$ как здесь

int intNumber = 5;
float floatNumber = 5.765f;
String stringVar = "fuck you";
System.out.printf("int = %d%nfloat = %.2f%nString = %s", intNumber, floatNumber, stringVar);

Вывод:
int = 5
float = 5,76
String = fuck you






















Создание JAR файлов(.jar консольное приложение)

Создать:

File (Top menu) -> Project Structure -> Artifacts -> + -> JAR -> From modules with dependencies -> Main class -> OK

Build (Top menu) -> Build artifacts -> Build


Открыть:

1) В консоли добраться до директории где находится .jar файл(через cd или открыть консоль сразу в нужной папке)

2) java -jar todolist.jar





















Java profiling(проверить скорость работы и кол-во запросов к процессору)





























































Работа с файлами и папками, класс File, работа с папками

"/users/egor/desktop" - абсолютный путь
"data/info.txt"       - относительный (значит он в папке с проектом)


File file = new File("data/info.txt") - создание обьекта типа File

file.length() - размер в байтах
file.delete() - удалить
file.lastModified() - когда последний раз был изменен
file.mkdir()  - создать папку по названию file(прямо в переменной file должно быть название новой папки)


















Копирование файлов, скачиваение файлов, FileUtils

ЛУЧШЕЕ ДЛЯ РАБОТЫ С ФАЙЛАМИ И ПАПКАМИ, ЛУЧШИЙ КЛАСС ДЛЯ КОПИРОВАНИЯ, ЛУЧШИЙ СПОСОБ СКОПИРОВАТЬ


Супер офигенная библиотека для простой работы с файлами.

Добавить библиотеку apache.commons.io:

        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.7</version>
        </dependency>




Скопировать папку целиком:

File dir = new File("/users/egor/downloads/Архив");
File copyDir = new File("/users/egor/desktop/Архив");

FileUtils.copyDirectory(dir, copyDir);




Скачать файл из URL:






























Копирование с помощью Files, file, копирование папок и файлов, копирование файлов, скопировать папку


Смотри в проектах с названием "(TESTER) Класс Files, Копирование папок и файлов"





Если коротко пример:

Files.copy(from.toPath(), copy.toPath()); - оба параметра должны быть класса Path и полным путем типа 

"/users/egor/DOWNLOAND/Привет.mp3" и второй параметр тоже "/users/egor/DESKTOP/Привет.mp3", плюс все папки на пути к копии должны существовать или быть созданы через mkdir()





















































HTML Парсинг, html parsing, html parse, парсинг html, JSOUP

Пример можно посмотреть в "(TESTER)HTML & JSON Parse HARD"



Для начала нудно скачать библиотеку Jsoup или добавить зависимость в Maven:

<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.13.1</version>
</dependency>




Через // указан вывод метода



Document doc = Jsoup.connect("https://lenta.ru/").maxBodySize(0).get(); - подключаемся к сайту, maxBodySize убираем ограничение по буферу, по умолчанию Jsoup читает 2 Мб данных с запрашиваемой страницы

Elements elements = doc.select("img");
// ARRAY[]: <img alt="" class="g-picture" style="max-width: 300px; width: 300px; height: 200px;" src="https://icdn.lenta.ru/images/2020/08/02/13/20200802132326488/top7_d0e496f7c490cf3ff91da9af7c61bc87.jpg" width="300" height="200">

String imgUrl = elements.get(0).attr("abs:src"); - для примеру используем лишь 0 элемент в массиве, на деле можно перебрать все через forEach()
// https://icdn.lenta.ru/images/2020/08/02/13/20200802132326488/top7_d0e496f7c490cf3ff91da9af7c61bc87.jpg

String[] urlSplit = imgUrl.split("/");
// [https:, , icdn.lenta.ru, images, 2020, 08, 02, 13, 20200802132326488, top7_d0e496f7c490cf3ff91da9af7c61bc87.jpg]

String imgName = urlSplit[urlSplit.length - 1];
// top7_d0e496f7c490cf3ff91da9af7c61bc87.jpg

URL url = new URL(imgUrl);             - переменная типа URL для InputStream'а, чтобы использовать url.openStream()

String destName = "images/" + imgName; - эту переменную используем как имя файла когда будет его сохранять





Пример:

<img alt="" class="g-picture" style="max-width: 300px; width: 300px; height: 200px;" src="https://icdn.lenta.ru/images/2020/08/02/13/20200802132326488/top7_d0e496f7c490cf3ff91da9af7c61bc87.jpg" width="300" height="200">

<img  - тэг

class - класс

style - атрибут, так же как и src, width, height и тд


https://jsoup.org/cookbook/extracting-data/selector-syntax     - это туториал по селектору


.select() - отсортировать по какому то значению

.select("div") - это по тэгу, просто текст
.select(".name") - по имени класса, то с точкой (class) 
.select([data-line]) - по имени аатрибута
.select("[data-line=1]") - через = по имени и значению атрибута
.select("[data-line*=val]") - через аттрибут, и содержит значение "val" атрибута
.select("[[attr~=regex]]") - через атрибут, а значение сортируем по regex

img[src~=(?i)\.(png|jpe?g)] - тэг img, аттрибут src, значение которого подходит по regex выражению после =

.attr("title") - выдает значение атрибута





















































Чтение из файла(reading file), Класс File



По крутости и короткости:

FileInputStream -> BufferedReader -> Files.readAllLines











С помощью класса Files, readAllLines, read all lines (САМЫЙ ХОРОШИЙ!!!) 


Самый современный и мощный способ, может и записывать и читать с файла



Короткая запись:
List<String> lines = Files.readAllLines(Paths.get("data/staff.txt"));



Пример:

StringBuilder builder = new StringBuilder();                                - в этот builder будет записываться весь текст

try {                                                                       - проверяемый exception, нужно обнести try/catch

    List<String> lines = Files.readAllLines(Paths.get("data/Заметки.txt")); - метод сразу записывает все лайны в List<String>
    lines.forEach(line -> builder.append(line + "\n"));                     - не забываем добавлять "+ \n" после каждой линии, чтобы текст вышел как надо


} catch (Exception e) {
    e.printStackTrace();
}






То же самое через readAllBytes:


        StringBuilder builder = new StringBuilder();

        try {

            byte[] lines = Files.readAllBytes(Paths.get("data/Заметки.txt"));

            for(byte element : lines){
                char word = (char) element;
                builder.append(word);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
















С помощью FileInputStream, File input stream


Это самый древний способ который есть почти в каждом языке, он читает код каждого символа, который потом вручную нужно перевести в буквы и цифры




Пример:


StringBuilder builder = new StringBuilder();                      - сюда будет записываться весь текст

try {                                                             - его обязательно обрабатывать, проверяемый exception
    
    FileInputStream is = new FileInputStream("data/Заметки.txt"); - создаем обьект FileInputStream с указанием пути к файлу
            
    for (; ; ) {                  - создаем бесконечный цикл
        
        int code = is.read();     - код символа
        if (code < 0) {           - если код ниже ноля, значит файл закончился и нужно прервать цикл
            break;
        }
        char ch = (char) code;    - преобразуем код в char
        builder.append(ch);       - добавляем символ в builder
    }

    is.close();                            - FileInputStream нужно закрывать после использование

} catch (Exception e) {
    e.printStackTrace();
}

















С помощью BufferedReader, buffered reader


Может читать по линиям, однако все пишет в одну линию, поэтому нужно вручную добавлять \n после каждой линии




Пример:



StringBuilder builder = new StringBuilder();                                    - в этот StringBuilder будет записываться весь наш текст

try {                                                                           - проверяемый exception нужно обнести try/catch

    BufferedReader br = new BufferedReader(new FileReader("data/Заметки.txt")); - фсоздаем обьект BufferedReader, ему в параметр должен идти FileReader, поэтому создаем его

    for (; ; ) {                           - создаем бесконечный цикл 
        
        String line = br.readLine();       - лайн который читается нашим BufferedReader
        if (line == null) {                - если линия null значит файл закончился, выходим из цикла
            break;
        }
        builder.append(line + "\n");       - заполняем наш builder лайнами, но не забыть добавлять "+ \n" после каждого лайна 
    }

    br.close();                            - BufferedReader нужно закрывать после использование

} catch (Exception e) {
    e.printStackTrace();
}



































Запись в файл, PrintWriter, print writer


.flush() - сбрасывает буфер, из-за структуры памяти, записывать в нее инфу по-символьно это очень накладно и не оптимизированно, поэтому нужно записать сразу множество инфы и потом за один раз все записать, потому что процесс "передачи" имеет "накладные расходы"












Через OutputStream, сохранение картинок, запись картинок


OutputStream пишет байтами, а значит универсален и может сохранять любую информацию

Полный пример в проекте "(TESTER) HTML Parsing & Image Copy"

Пример:


URL url = new URL(imgUrl);                                - переменная класса URL, принимает стринг пути, типа "https://...."      
String destName = imagesFolder + imgName;                 - это путь к сохранению файла, там должно быть имя папки(она должна быть создана) и имя самого файла с расширением в конце

InputStream inStream = url.openStream();                  - так мы открываем стрим байтов с сайта
OutputStream outStream = new FileOutputStream(destName);  - переменная уже держит в себе путь к созранению файла

byte[] buffer = new byte[2048];                           - буфер в который будем записывать файл

int length;                                               - кол-во прочитанных байтов, в нашем случае это от 1 до 2048(размер буфера)
                                                          - inStream читается и пишется в buffer, потом возвращаемся и пишем 2048 байт заново .read() запускает процесс чтения
while ((length = inStream.read(buffer)) != -1) {          - read() возвращает кол-во прочитанных байтов, -1 означает конец стрима, байты больше не идут
    outStream.write(buffer, 0, length);                   - buffer инфа которую пишем, 0 это офсет, или отступ точки начала, length указываем сколько именно байтов записать
}                                                         - то есть буфер всегда 2048, а если он не полный, нам нужно записать только то, что записалось без лишнего(там 0,0,0,0...)

inStream.close();
outStream.close();


























Через PrintWriter

Пример:

try {

    PrintWriter writer = new PrintWriter("data/file.txt"); - создаем обьект PrintWriter

    for (int i = 0; i < 1000; i++) {                       - запишем в него числа от 0 до 1000
        writer.write(i + "\n");                            - так записывается
    }

    writer.flush();                                        - этой командой "толкаем" все что записано в файл
    writer.close();                                        - закрываем наш writer

} catch (FileNotFoundException e) {
    e.printStackTrace();
}
















Через Files.write()



try {

    List<String> strings = new ArrayList<>();          - создаем массив строк

    for (int i = 1000; i > 1; i--) {
        strings.add(Integer.toString(i));              - добавляем в массив числа от 1 до 1000
    }
            
    Files.write(Paths.get("data/file.txt"), strings);  - используем метод, первым параметр - путь, второй - массив с которого считать строки и записать в файл

} catch (Exception e) {
    e.printStackTrace();
}









































Json, JSONParser, работа с файлами JSON, json parse


Как получить:

Maven

        <dependency>
            <groupId>com.googlecode.json-simple</groupId>
            <artifactId>json-simple</artifactId>
            <version>1.1.1</version>
        </dependency>


JSON - JavaScript Object Notation - текстовый формат обмена данными, проихошедший от JacaScript, но читаемый почти любым языком

>>> - тип данных





JSONObject.get("name") - JSONObject может читать поключам из файла

JSONArray.get(0)       - JSONArraн может читать по индексам, создается из JSONObject по ключу (JSONArray) fullFile.get("lines")






Создание:

JSONObject test = (JSONObject) parser.parse(builder.toString())   - создается парсингом из String

JSONObject test = (JSONObject) linesArray.get(0)                  - либо по индексу какого-то JSONArray

JSONArray array = (JSONArray) fullFile.get("lines")               - создается из JSONObject по ключу




2
Пример кода:


String dataFile = "src/main/resources/map.json";                                      - создаем переменную пути к файлу

List<String> listOfLines = Files.readAllLines(Paths.get(dataFile));  >>> List <String> - переводим в Лист стрингов(линий, он читает он по лайнам) через Files.readAllLines

StringBuilder builder = new StringBuilder();                                          - создаем StringBuilder

listOfLines.forEach(line -> builder.append(line));                   >>> String       - заполняем билдер, переводим в однин длинный String 

JSONParser parser = new JSONParser();                                                 - создаем парсер, он парсит String в JSONObject

JSONObject fullFile = (JSONObject) parser.parse(builder.toString()); >>> JSONObject   - это весь файл json, переводим билдер в стринг и в JSONObject

JSONArray linesArray = (JSONArray) fullFile.get("lines");            >>> JSONArray    - из целого файла создаем JSONArray по ключу "lines"



JSONObject firstStation = (JSONObject) linesArray.get(0);            >>> JSONObject    - получаем обьект только по 1 станции по индксу 0

System.out.println(((Long) firstStation.get("number")).intValue());  >>> Object        - получаем number этой станции, метод .get у JSONObject возвращает всегда Object, поэтому его 
нужно всегда кастить, здесь кастим в обьект Long, чтобы получить метод intValue(), и помещаем все выражение в скобки

System.out.println((String) firstStation.get("name"));               >>> Object        - получаем name этой станции и кастим в String

System.out.println((String) firstStation.get("color"))               >>> Object        - получаем color станции и кастим в String

































Generics

List <> - в <> скобках это generic

List <? extends Comparator> - создание листа с generic, который принимает любой класс, имплементирующий Comparator











































Система сборки Maven

Maven - фрэймворка для автоматизации сборки проектов

New Project ->
Maven (Слева выбрать) -> 
GroupID (название проекта), ArtifactID (название jar файла) -> 
Enable Auto-import
src/main/java - здесь создаем классы java и работаем здесь
pom.xml - открыть

    <dependencies>
        <dependency>
            <groupId></groupId>
            <artifactId></artifactId>
            <version></version>
        </dependency>
    </dependencies>





mvnrepository.com - место где можно искать библиотеки












































Аннотации

Это типа 
@Override   - значит метод перезаписан
@Deprecated - значит метод устарел, и будет отображен зачеркнутым


Lombok ламбок ломбок лобок

Это библиотека, ее нужно либо установить, либо через maven

Lombok - это плагин, позволяющий работать с аанотациями, он может:

1) Заменять класс типа @ToString, пишется над именем класса

@ToString
public class Employee {

1a) Можно вычитать переменные из этих методов типа:

@ToString(exclude = "name") - будет создан метом toString() для всех переменных кроме name

2) Заменять Геттеры и Сеттеры:

@Getter @Setter
private String name; - теперь у name есть геттер и сеттер
private int age;

3) Установить методам уровень доступа

@Getter (AccessLevel.PROTECTED)

4) Указывать параметры аргументам типа @NonNull

5) @Data - автоматом устанавливает для всех полей Getter, Setter, ToString, canEqual, Equals, hashCode

6) @AllArgsConstructor - создать конструктор из всех полей по порядку

7) @RequiredArgsConstructor - создать конструктор из всех полей @NonNull


































Exception procession (обработка исключений ошибок) try catch








TRY/CATCH

Пример:

try {
    System.out.println(names[4]);
} catch (Exception e) {
    System.out.println(e.getMessage());
}


Можно также писать вместо Exception определенный типа, например 


try {
    System.out.println(names[4]);
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println(e.getMessage());
}



Методы:

e.getMessage() - выводит сообщением 

e.printStackTrace();






















THROWS

Можно и так:

String names = "Egor Lola Tasia";
String[] array = names.split("\\s+");
if (array.length != 3) {                                  - если длина массива после деления не равна 3, то
    throw new IllegalArgumentException("Wrong format");   - создать новове исключение с сообщением "Wrong format"
}




Полный код будет выглядеть так:

        try {
            String names = "Egor Lola Tasia Roma";
            String[] array = names.split("\\s+");
            if (array.length != 3) {
                throw new IllegalArgumentException("Wrong format");
            }
        } catch (IllegalArgumentException ex) {
            System.out.println(ex.getMessage());
        }






Типы исключений:

IOException (Checked Exception) - исключения, которые ты ОБЯЗАН обработать, иначе программа даже не запустится

Пример:

    public static void main(String[] args) throws IllegalArgumentException {

        try {
            List<String> lines = Files.readAllLines(Paths.get("file.txt"));   - метод readAllLines должен быть обработан, можно обратотать через try/catch
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


А можно так:




public static void main(String[] args) throws IOException {                 - здесь мы говорит что метод выкидывает это исключение
            List<String> lines = Files.readAllLines(Paths.get("file.txt"));
    }




Runtime Exceptions (Unchecked Exception) - это ошибки программиста, либо защитить от неправильного использования пользователем















Checked Exception - исключения, которые ты ОБЯЗАН обработать, иначе программа даже не запустится

Unchecked Exception - исключения, которые ты можешь обработать по желанию

StackOverflowError - если метод вызывает сам себя более 256 раз, грубо говоря сам себя вызывает

OutOfMemoryError - приложение занимает слишком много памяти, нужно оптимизировать приложение или увеличить память











































DEBUGGER, DEBUG, Дебагер

точка - называются brakepoint, это точка, где программа остановится

кнопка дальше - переносит к следующему breakpoint

step into (F7) - продолжить выполнение кода, жагнуть в код как бы

step over (F8) - перейти к след строке кода



Все ошибки исправлять и искать принято использую именно debugger












































Виды тестирования ПО


1) Функциональное тестирование - проверяется вся или базовая функциональность ПО

   а) Тестирование черного ящика - когда не знаешь внутренний код и как он написан (к примеру работает ли выделение жирным у Ворда или не работает)
   б) Тестирование белого ящика - когда знаешь внутреннюю структуру, возможные баги, тестирование с учетом этих знаний

2) Регрессионное тестирование - влияние новых функций и фич на старые, то что предыдущие функции по прежнему работают

3) Интеграционное тестирование - проверить работы всех компонентов системы (к примеру базы данных, дроп бокс интеграция, смс инт-я и тд)

4) Тестирование производительности 

5) Тестирование безопасности - как легко взломать и тд

6) Юзабилити-тестирование - насколько удобно ваше приложения, расположение кнопок, логика интерфейса и тд

7) Модульное тестирование - его пишут программисты, пишется в коде, позволяет проверить отдельные методы и классы




Тестирование бывает:

Ручное (например юзабилити)

Автоматизированное (например модульное)


Есть методология разработки TDD - Test-driven development (разработка через тестирование, сначала пишешь тест, покрывающий этот код, затем код который пройдет тест, а потом рефакторинг)











Модульное тестирование, тестирование, testing


JUnit - библиотека для тестирования (в любом языке есть такая библиотека с приставкой Unit)


1) Создаем проект Maven
2) Делаем dependency от junit
3) В папке src -> test -> java   создаем класс (к примеру TestCalculator)
4) У этого класса написать extends TestCase
5) Переопределяем метод SetUp, где будут условия для нашего теста
6) Создаем метод, который будем тестировать, ОН ДОЛЖЕН НАЧИНАТЬСЯ С "test" (например на Calculator -> testCalculator)
7) Переменная actual   - инфа, которую получаем по факту
8) Переменная expected - инфа, которая ДОЛЖНА быть, если метод работает правильно










































Настройка Intellij IDEA



Release version 5 not supported

Preferences -> Build, Execution, Deployment -> Compiler -> Java Compiler -> Pre-module bytecode version -> 11

Project structure -> Modules -> Sources, Dependencies   - ставим везде нужную версию Java





Добавить поддержку Maven или другого Framework в проект

Нажать на корневую папку проекта -> Add dramework support














































Logging, Логирование, Логгирование, log, log4j

Логгирование - запись ошибок или чего либо в файл (в лог), для того, чтобы потом при необходимости посмотреть что происходило с нашей программой в определенный момент

1) Создаем проект Maven

2) Создаем dependency:

        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.13.3</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.13.3</version>
        </dependency>

3) Инициализируем: 

Logger logger = LogManager.getRootLogger();   - Logger(org.apache.logging.log4j)

4) src/main/resources - создаем файл log4j2.xml

5) Пишем стандартную конфигурацию (в инете есть) : 



<?xml version="1.0" encoding="UTF-8"?>
<configuration status="WARN">
  <appenders>
    <Console name="Console" target="SYSTEM_OUT">                                                     - пишет в консоль
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>

    <File name="MyFile" fileName="logs/app.log">                                                     - пишет в файл
        <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </File>             
  </appenders>

  <loggers>     
    <root level="debug">
      <appender-ref ref="Console" level="info"/>
      <appender-ref ref="MyFile" level="error"/>
    </root>    
  </loggers>
</configuration>








append="false" - лог перезаписывается при каждой новой инфе



Levels уровни доступа логера:

OFF	0
FATAL	100
ERROR	200
WARN	300
INFO	400
DEBUG	500
TRACE	600
ALL	Integer.MAX_VALUE

















Конфигурация, при которой логи записываются в 3 разных файла, в зависимости от того, как назван logger.


<?xml version="1.0" encoding="UTF-8"?>
<configuration status="WARN">
    
    <appenders>                                                                                           - здесь указываются аппендеры, куда уходит инфа о логах(консоль или файл)
        
        <File name="root" fileName="logs/root.log">                                                      
            <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>     - формат вывода информации в лог
        </File>
        <File name="search" fileName="logs/search.log">                                                   - name это имя аапендера, которое указывается в loggers ниже
            <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </File>
        <File name="errors" fileName="logs/input_errors.log">
            <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </File>
        <File name="exceptions" fileName="logs/exceptions.log">                                           - после fileName можно добавить append="false", тогда лог будет 
            <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>       перезаписываться при каждом ПЕРЕЗАПУСКЕ программы
        </File>

    </appenders>

    <loggers>                                                - все логгеры
        
        <root level="info">                                  - должен быть всегда один root logger
            <appender-ref ref="root"/>                       - appender ref это то, в какое место(файл или консоль) будет записываться лог
        </root>

        <logger name="search" level="info">                  - name="search" это имя логгера, в который будет записываться вся инфа
            <appender-ref ref="search"/>                     - level это уровень доступа
        </logger>

        <logger name="errors" level="info">
            <appender-ref ref="errors"/>
        </logger>

        <logger name="exceptions" level="info">
            <appender-ref ref="exceptions"/>
        </logger>
        
    </loggers>

</configuration>


















Создание в проекте:


Logger logger = LogManager.getRootLogger();      - можно рут логгер

Logger logger = LogManager.getLogger("search");  - можно с именем, тогда в него будет записываться лог, настроенный только на его имя



String input = scanner.nextLine();                              - для примера логгеру нужно выводить что пишут в консоль

logger.info/debug/trace/error("Пользователь ввел: " + input)    - вот так можно записать инфу в логгер



















































Parse таблиц, парсинг таблиц, парс таблиц, парс excel, табличные файлы


Сохранить файл в формате:

"Текст с раделителями-символами табуляции.txt"

Или

"Текст с разделителями-запятыми.csv" - Comma separated




















































JDBC

JDBC - Java DataBase Connecivity

Это драйвер(библиотека в Java) который позволяет подключиться к любой базе данных(MySQL, PostGre и тд)
То есть для работы с разными базами данных используются одни и те же методы
Каждый вендор разных баз сам создает свой драйвер в JDBC
По сути может только делать запрос или обновлять/удалять/добавлять строки
Главный минус это неудобство работы с Обьекатми, именно для этого и существует Hibernate




        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.22</version>
        </dependency>









            String url = "jdbc:mysql://localhost:3306/skillbox";
            String user = "root";
            String pass = "password";

            Connection connection = DriverManager.getConnection(url, user, pass);   - подключение к базе данных по урлу юзеру и паролю
            Statement statement = connection.createStatement();                     - через эту переменную мы делает запросы к БД
            ResultSet resultSet = statement.executeQuery("SELECT * FROM Students")  - здесь по сути результатом является таблица по вашему SQL запросу

            while (resultSet.next()) {                                              - здесь выводим результат нашего запроса с resultSet'а
                String name = resultSet.getString("name");
                System.out.println(name);
            }



Остальное в проекте (TESTER) JDBC


JPA - Java Persistence API - это стандарт, который ввел JCP(Java Commubity) после успеха Hibernate, и которому должны соответствовать все ORM системы





























































                                                                                        Spring Boot, Spring Framework


                                                  !!! Всё что нужно описано в проекте "(Theme) Spring, Web Development/ToDoList Learn !!!


                  !!! Лучшие видео по теме в избранном на YouTube "Spring Boot Tutorial | Full Course [2021] [NEW]" и "Spring Boot Tutorial for Beginners (Java Framework)" !!!

                                        


Controller - класс, который выдает информацию в ответ на запрос. Получает запрос -> отправляет ответ

Коды Ответов HTTP:

200 - OK

400 - BAD REQUEST (неправильный хапрос)

403 - FORBIDDEN (доступ к сущности запрещен)

404 - NOT FOUND (запрос к сущности, которая не существует)

500 - INTERNAL SERVER ERROR (ошибка на сервере, или он перегружен)















































                                                                   HTML, CSS. JavaScriipt, Java Script, js



                                            !!! В проекте "IdeaProjects/js-basics/index.html" все более менее написано про HTML и CSS и JS !!!
  
                                    
                                                    !!! В проекте "(Theme) Spring, Web Development/ToDoList" много JS !!!


















































                                                                JVM parameters, увеличить память Java, -Xms, -Xmx, память JVM


java -X     - в консоли чтобы увидеть все параметры JVM


В проекте сверху на имя Main класса, слева от молоточка build -> Edit configurations -> VM Options






synchronized значает "Тебе нужно иметь монитор (этого) обьекта, чтобы выполнить код ниже"
testThread.join() значит "Подождать пока testThread умрет, потом выполнить код дальше"
this.wait() значит "Усни и освободи монитор (this) обьекта. Сам тред при этом должен иметь монитор (this) обьекта"
this.notify() значит "Разбуди случайный тред, который спит и ожидает монитор (this) обьекта. Сам тред при этом должен иметь монитор (this) обьекта"









Разница версий Джава

Дженерики это обобщение которое стирается в рантайме
Дженерики нужно сделать пример вручную
Wildcard дженериков
Паттерны почитать декоратор, прокси, фактори, стратегия, chain of responsibility, барьер
default методы в интерфейсах
Конкретные отличия интеферйса и абстрактного
Интерфейсы с одинаковыми методами
Методы Object в интерфейсах
Блоки{} в интерфейсах
Инкапсуляция и интерфейсы
Доклад Егор Бугаенко
Бот со спрингом который Мониторит наличие ПС5
Spring Security
Spring MVC
JDBC, Entity manager, JDBC Template
Spring без стартеров
Spring
JSR
















epam через стажировку
с конца марта
обучающие курсы
тестовые задания epam
3-4 штуки проектов

ФОРМИРОВАНИЕ ПОРТФОЛИО
Дипломный проект
Опенсорс проекты попробовать
Резюме начинаю готовить
Шаблон на скиллбоксе взять
Резюме в шаблоне скилбокс, во внешнем шаблоне
Сопроводительное письмо





Reentrant lock
Кондишены
yaml актуальнее
request chain id
резюме можно заполнять, отправить Сане
сначала гуглить, а потом спрашивать
смотреть инфу о компании

Вопросы собеседнику после собеса
О компании кратко
Стэк какой используется
Архитектура какая, микросервис или нет
какой сборщик проектов
как устроенны внутренние процессы
будет ли у меня ментор?
Попросить feedback, что подтянуть, где проблема







Я не технарь, но на работе научился технической сфере
Указать весь опыт работы
Я бросил работу ради этого























SOLID
Single responsibility - обьект должен выполнять только одну функцию.
Пример: 
ArrayList работает с листом, и все методы работают с Листом, если бы мы хотели добавить туда метод из Math, который считает сумму двух чисел, это было бы нарушением принципа.

Open-closed - Обьекты должны быть открыты для расширения, но закрыты для модификации.
Пример: 
Создаем метод, который в зависимости от Животного издает разные звуки.
От Animal наследуется куча животных, и когда мы передаем в метод Животное, внутри метода пишем кучу if на проверку какое это животное, и делаем соответственный sout("bark") если Собака и тд.
Но для каждого нового Животного придется лезть в этот Обьект.
Решение - создать в Animal метод speak() и каждое животное реализует его по своему, а метод просто вызывает animal.speak() внутри.

Liskov substitution - если Родитель реализует определённое поведение, то это поведение должно быть корректно реализовано и для всех его наследников.
Пример:
Класс Collection имеет метод add() и не смотря на то что наследники совершенно разные структуры данных, этот метод сохраняет свою логику во у всех Наследников.

Interface segregation - не нужно делать слишком "толстые" интерфейсы, тк это может приветси к тому, что Клиенту придется реализовать методы, которые не имеют для него смысла.
Пример:
Runnable и Callable, если бы Runnable также имел метод call(), то нам пришлось бы его как-то реализовывать или оставлять пустым.
Или List, у LinkedList есть метод addFirst(), однако у других листов его нет и не имеет смысла, так что это было бы лишним нагромождением.

Dependency Inversion - высокоуровневые модули не должны зависеть от низкоуровневых, а оба должны зависить от Абстракций. Это очень похоже на принцип "программируй на уровне интерфейсов, а не реализаций". По сути это о том, чтобы не создавать "сильные" зависимости.
















workflow
фронт пишется
базовые знания в html, css, javascript
работа с ними будет
очень тесное взаимодействие с БД
SOQL
trailhead

Флоу гита
Scrum
Работают по спринтам, по 2 недели
Тестирование после pull request
Код ревью делают все
Девлид = тимлид

Юрий
Сергей
Максим


















16 00 мск skype обьяснить дз  ооп sql субд abap общее представление 



Андрей
Владимир


связанность. зацепление

Ищут людей, которые хотят этим заниматься, 
будет куратор
но много самостоятельной работы
3 месяца испытательный срок
стажировка 6 месяцев

второй этап
на 2 вечера документация с первого урока. 
Документ на 400 страниц англоязычный
темы, которые нужно будет изучить
2 этап интервью
на 3й день делаю небольшой доклад по темам

мониторить скайп до вечера понедельника
если не появится ничего, значит отказ














1000 долларов
13%
65 тыс на руки
программа сертификации распространяется, 5 уровней, за каждый уровень 250 долларов, 
slack общение
про устройство к девочкам



































