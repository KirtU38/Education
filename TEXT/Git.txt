1) Создаешь новую ветку
2) push на GitHub в новую ветку 
3) Создаешь Pull Request(на самом GitHub или вручную, или интеллич)
4) Merge этот Request в master ветку


Pull Request - запрос на добавление в ветку(master) каких то изменений, типа "Прошу сделай Pull на эти изменения"



Git, Github

Git - система контроля версий, которая позволяет осуществить параллельную разработку
commit - версия кода
head - последний коммит, голова
ammend - добавить нынешнее изменение в предыдущий коммит(к примеру если забыл что-то внести, и не хочешь ради этого создавать новый коммит)

cd - change directory 
cd - назад
ls  - лист содержимого

Стадии коммита:
Изменен  ->  Готов к комиту  ->  Закомичен
             git add         ->       git commit

Вернуть изменения можно ТОЛЬКО когда файл не индексирован(unstaged)


Новая версия  ->  Старая версия         - сейвово, создает новый коммит с подписью
      git revert "короткий номер"


Reset, возвращаемся к предыдущим коммитам:
Soft  - удаляет пред коммиты, оставлет код, сразу индексирует разницу (staged зеленый) 
Mixed - удаляет пред коммиты, оставлет код, не индексирует разницу (unstaged красный) 
Hard  - удаляет пред коммиты, удаляет код, который не совпадал

git reset --mixed(soft, hard) "короткий хэш" - вернуться в определенному комиту
git reset --hard - вернуться к поледнему комиту и удалить все эксперименты и тд 


Новая версия  ->  Старая версия         - не сейвово, удаляет пред комиты
      git reset "номер"


Добавление в старый коммит через --ammend:
Старый коммит -> Изменения -> Старый Коммит
                       git add     ->    git commit --amend        


Связывание репозитория с Онлайн репозиторием:
git init - Создаем репозитори
git clone "ссылка" - клонируем и связываем


Работа с удаленным репозиторием(УР):
git push - отправить изменения в УР
git push -f - отправить изменения в УР, даже если ты ресетнул изменения к предыдуший(force push)
git pull   - скачать и слить уд-й реп-й с локальным
git fetch - скачать но не сливать УР с локальным, чтобы влить потом пишел git pull
git diff master..origin/master - сравнить файлы из УР с локальными файлами после команды fetch


cd ideaprojects - перейти в папку проектов
cd .. - вернуться назад
git init - создать репозиторий в папке где находишься

git add "файл" - проиндексировать файл, подготовить к коммиту
gid add .  - точка значит добавить ВСЕ измененный файлы
git add -p - добавить только часть кода
git commit    - закомитить
git cimmit -a - сразу заиндексировать и закомитить все изменения
git commit -m "name" - закомитить с измененный именем
git status - показать какие файлы изменены
git log - показать историю коммитов
git show - показать последний коммит
git remote - показать имя удаленного репозитория
git remote -v - показать адрес удаленного репозитория
git -p test.jar - заиндексировать только часть файла
git mv "имя файла" "новое имя файла" - переименовать
git diff "номер" "номер" - просмотреть изменения в коммитах
gid diff HEAD~1 - показать последнее изменение в последнем головном коммите
Q - выйти из режима просмотра(log, diff)
. - точка значит ВСЕ файлы


Branches, ветки:
git checkout -b "имя" - создать новую ветку
git checkout "имя ветки" - переключиться на ветку
git branch -m "старое имя" "новое имя" - переименовать ветку
git branch -l - показать все ветки в проекте
git branch -d "имя ветки" - удалить ветку
git push --delete origin(имя реп-я) "имя ветки" - удалить ветку с удаленного репозитория
git merge "имя ветки" - слить ветки



Указатели:
Синий   - изменено
Зеленый - добавлено новое
Серый   - закомичено либо бещ изменений

3 секции:
Проиндексированные    (Готовые к коммиту)
Не проиндексированные (Не готовые к коммиту)
Не отслеживаемые      (Они вообще не отслеживаются гитом)

В каждой секции могу быть файлы:
Измененные
Добавленные
Удаленные

Исключение файлов из отслеживания:

Можно сгенерировать на gitignore.io

создаем файл .gitignore
в нем пишем названия файлов:

/src/logs    - заигнорить всю папку
form.html    - заигнорить один файл

Удалить из отслеживания через консоль:
git rm --cached "имя файла" - удалить именно из гита
git rm "имя файла"          - удалить вообще из файловой системы

чтобы изменения вступили в силу, нужно закоммитить .gitignore


Полезные инструменты:

Stash
Позволяет быстро созранить изменения, не делая комит
В IDEA VCS -> Git -> Stash(UnStash)

Annotate
Показывает кто и когда написал строку кода
ПКМ на файл -> Git -> Annotate
или
git blame "file"


Правила работы:

Ветки называются по своему назначению (Master, Hotfix, Develop)
не по дате, не по тому, что добавлено, именно по своему назначению 

Коммиты должны быть осмысленными, не нужно коммитить одну строчку
Обычно коммитят одну цельную выполненную задачу
Исключением является ветка Hotfix, она создана для мелких коммитов

Ставить номер задачи в начале коммита

Перед git push сделать git pull и решить конфликты если они будут


























BRANCHES
git branch            - показать все ветки.
git checkout name     - перейти на ветку name.
git checkout -b name  - создать ветку name.
git branch -d name    - удалить ветку name.



git rm file           - удалить file вообще.
git rm --cached file  - удалить file только с гита.
git add file          - stage for commit file.
git reset file        - unstage file.
git restore file      - rollback, все что изменили вернуть назад.


git revert HEAD        - создать новый коммит, который отменяет изменения предыдущего
git reset --mixed id   - вернуть ветку к коммиту id 


git reflog   - история коммитов, смены веток.
git log      - история коммитов.
git log --oneline - самый удобный

git push                             - это когда настроен upstream, то есть мы в какой remote мы пушим и ветка уже существует .
git push --set-upstream origin test  - а это когда ветки на GitHub нет, нам надо ее создать.



git fetch    - скачать коммиты с remote ветки, но не merge их в локальную.
git merge    - сливает выбранную локальную ветку с соответствующей ей remote веткой (с коммитами, которые мы скачали с remote).
git pull     - это fetch -> merge, делает сначала fetch, то есть скачивает коммиты с remote ветки, и сливает в локальную ветку.




fork - это на гитхабе как скопировать репозиторий.




Workflow:
1) Создаешь новую ветку.
2) push на GitHub в новую ветку .
3) Создаешь Pull Request в самом GitHub, pull request с ветки test -> master (на самом GitHub или вручную).
4) Тимлид Merge`ит этот Request в master ветку Гитхаба.
5) Делаешь pull с remote на local командой pit pull.


Создание нового репозитория:
1) Создаешь на Гитхаб
2) Клонируешь на комп (git clone ...) 

При таком создании нам не нужно будет настраивать remote каждый раз











Rebase vs Merge

Rebase:

main:    a -> b -> 1 -> 2
                  /
test:       1 -> 2

При Rebase добавляются все комиты с ветки поверх последнего коммита в main.


Merge

main:    a -> b -> c (merged commit)
                  /
test:       1 -> 2

При Merge создается один коммит, в котором Сливаются последние изменения с Ветки test.











