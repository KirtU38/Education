package com;

import com.test.classes.human.Human;
import com.test.classes.human.Man;

import java.util.ArrayList;
import java.util.List;

public class Main {
  public static void main(String[] args) {

    // Обычные массивы в Джаве Ковариантны
    String[] strArr = {"Egor", "Tasia", "Roma"};
    Object[] objArr = strArr;

    // Дженерики в Джаве Инвариантны
    // Object родитель Human, Man наследник Human, однако нельзя им присвоить ссылку на List<Human>
    List<Human> listOfStrings = new ArrayList<>();
    // List<Object> listOfObject = listOfStrings;
    // List<Man> listOfMen = listOfStrings;

    // Однако можно добиться Ковариантности через wildcard
    // Man наследник Human, и такой записью мы добились Ковариантности
    List<? extends Human> list = new ArrayList<>();
    List<Man> listOfMen = new ArrayList<>();
    list = listOfMen;
    // В wildcard с ограничением сверху нельзя ничего добавлять, потому что
    list.add(null);
    Human human = list.get(0);

    // Однако можно добиться Контрвариантности через wildcard
    // Human родитель Man, и такой записью мы добились Контрвариантности
    List<? super Man> listMan = new ArrayList<>();
    List<Human> listOfHuman = new ArrayList<>();
    listMan = listOfHuman;

    listMan.add(new Man());
    Object human1 = listMan.get(0);
  }
}
// Generic - это средство языка позволяющее реализовать обобщенное програмирование.

// Все Дженерики нужны только Компилятору, в Рантайме они стираются и это называется erasure.

// type safety - обобщение обеспечивает нам безопасность типов, то есть в Лист<Стрингов> теперь
// нельзя случайно
// добавить число, что приведет к ошибке рано или поздно.

// wildcards - знак, передающийся в тип параметра.

// <Тип внутри> - называется element type("тип элементов") или type parameter("параметр типа").

// void print(List collection) - этот код означает "Принять Обьект Класса List или наследника List".
// void print(List<Animal> collection) - этот код означает "Принять Обьект Класса List<Animal> или
// наследника.
// ИМЕННО List<Animal>", то есть в Метод можно передать ТОЛЬКО List<Animal>, и даже если Car
// наследник Animal, List<Car> туда передать нельзя.

// Поэтому код:
// List<String> listOfStrings = new ArrayList<>();
// print(listOfStrings)

// Не сработает, потому что хоть String и наследник Object, однако именно List<String> это НЕ
// наследник List<Object>

// "В List<String> мы передаём в параметр типа Класс String, значит типом элементов в этом Листе
// будут Обьекты Класса String"
// <> - параметр типа
// String - тип элементов

// Типы Элементов:
// В Классе:
// 1) <Human> - с четким типом, но тогда мы лишаемся возможности использовать Тип как переменную,
// например как реализованно в Листе.
// 2) <T extends Human> - так мы задаём переменную T, и переданный Тип элементов можно будет
// подставлять в Методы как return type, Тип переменной или как Тип Элементов в Параметре, типа
// (List<T> list).
// 3) НЕЛЬЗЯ задать Типом Элементов Класса <T super Human>, тк теряется смысл Обобщения.
// Например List<String> дает гарантию что у всех Обьектов из этого Листа будут Методы Стринга,
// тк там будут либо Стринги либо его Наследники.

// В return type:
// 1) T - может задать Тип элементов Класса.
// 2) <C extends Human> C - по сути это равно если просто задать Human(по сути Human либо его
// Наследники), однако если зададим вот так, то сможем использовать переменную C как Класс
// принимаемого параметра (C human), что сократит код, либо как Тип Элементов другого Класса с
// Обобщением, типа (List<C> list).

// В параметрах:
// 1) (T human) - Тип элементов заданный при создании Обьекта.
// 2) (List<T> list) - можно передать Тип элементов Класса как Тип Элементов в List например.
// 3) (List<? extends Human> list) - можно передать сюда любой Лист, Тип Элементов у которого
// Human либо наследник Human. Это "Ограничение сверху".
// 4) (List<? super Human> list) - можно передать сюда любой Лист, Тип Элементов у которого
// Human либо родитель Human(LivingThing <- Object). Это "Ограничение снизу".

// Вариантности:
// Cat наследник Animal (Animal -> Cat)
// Ковариантность - это если бы List<Cat> мог считаться наследником List<Animal>
// Контрвариантность - это наоборот, если бы List<Animal> мог считаться наследником List<Cat>
// Инвариантность - когда List<Animal> это ТОЛЬКО List<Animal> и наследование не работает ни в одну,
// ни в другую сторону

// Массивы Ковариантны
// Дженерики Инвариантны

// Однако можно добиться Ковариантности и Ковариантности, смотри в коде выше.

// PECS - Producer extends, Consumer super.
// Означает что extends может только get(), а super может только add().

// Получить мы гарантированно можем Обьект Класса который высший в Иерархии, потому что
// "полученный элемент ТОЧНО будет наследником Класса который ВЫШЕ в Иерархии", то есть Cat точно
// ЯВЛЯЕТСЯ LivingThing например.

// Добавлять мы может только элементы которые либо указанного Класса, либо Класса наследника,
// например в List<Animal> мы можем добавить Animal, Cat, Dog, которые НИЖЕ по Иерархии.
// Но в List<Animal> мы не может добавить Родителя Object.
// "Мы уверенном можем добавить только элемент НИЖЕ всех в Иерархии, потому что он будет являться
// наследником".

// Ограничение сверху, Upper-bound wildcard
// Поэтому в List<? extends LivingThing> (LivingThing -> Animal -> Cat, Dog)
// У него СЕРХУ - LivingThing, а ВНИЗУ - Бесконечность, а значит их него мы ТОЧНО получим что-то,
// что является LivingThing, но добавить что-то конкретное не можем.
// Например мы add(new LivingThing), а будет List<Cat>, и туда можно только Cat или её наследников.
// Или мы add(new Cat), а Лист окажется Dog, который тоже наследует от Animal, тоже непорядок.

// Ограничение снизу, Lower-bound wildcard
// Допустим List<? super Cat> (Object -> LivingThing -> Animal -> Cat)
// Мы может ТОЧНО добавить Обьекты Cat, потому что Cat наследник ВСЕХ Классов выше, и в любой Лист
// он может быть добавлен, но нельзя указать Animal например, потому что вдруг окажется List<Cat>,
// в такой Лист мы не можем добавить Animal.
// А если получать из такого Листа, то мы может гарантировать только то, что все элементы будут
// наследниками Object который СВЕРХУ. Например если мы укажем у такого Листа
// Animal animal = list.get(0), то Лист может оказаться List<Object>, а Object не является Animal.
